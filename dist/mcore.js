(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("jquery")) : factory(root["jquery"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_4__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * @version 1.1.0
	 * @module mcore
	 * @author vfasky <vfasky@gmail.com>
	 */
	"use strict";
	var App, Stapes, Template, Ui, View, config, exports, route, util;

	util = __webpack_require__(1);

	route = __webpack_require__(2);

	config = __webpack_require__(3);

	Template = __webpack_require__(5);

	View = __webpack_require__(10);

	Ui = __webpack_require__(11);

	App = __webpack_require__(12);

	Stapes = __webpack_require__(9);

	exports = module.exports = {
	  util: util,
	  route: route,
	  config: config,
	  Template: Template,
	  View: View,
	  Ui: Ui,
	  App: App,
	  Stapes: Stapes
	};


/***/ },
/* 1 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * util
	 * @module mcore/util
	 * @author vfasky <vfasky@gmail.com>
	 */
	"use strict";
	var _cachePre, _isNumberReg, _localStorage, _memoryStorage;

	_isNumberReg = /^-{0,1}\d*\.{0,1}\d+$/;

	_cachePre = '__cache_';

	_localStorage = window.localStorage;

	_memoryStorage = {};

	exports.isNumber = function(x) {
	  return _isNumberReg.test(x);
	};

	exports.isObject = function(x) {
	  return Object.prototype.toString.call(x) === '[object Object]';
	};

	exports.isString = function(x) {
	  return Object.prototype.toString.call(x) === '[object String]';
	};

	exports.clone = function(value) {
	  return JSON.parse(JSON.stringify(value));
	};

	exports.cache = {
	  set: function(key, value, time) {
	    var data;
	    if (time == null) {
	      time = Infinity;
	    }
	    if (time !== Infinity) {
	      time = (new Date()).getTime() + parseInt(time);
	    }
	    data = {
	      time: time,
	      value: value
	    };
	    return _localStorage.setItem(_cachePre + key, JSON.stringify(data));
	  },
	  get: function(key, defaultVal) {
	    var curTime, data;
	    if (defaultVal == null) {
	      defaultVal = null;
	    }
	    data = _localStorage.getItem(_cachePre + key);
	    if (!data) {
	      return defaultVal;
	    }
	    data = JSON.parse(data);
	    curTime = (new Date()).getTime();
	    if (curTime <= data.time) {
	      return data.value;
	    }
	    exports.cache.remove(key);
	    return defaultVal;
	  },
	  remove: function(key) {
	    return _localStorage.removeItem(_cachePre + key);
	  }
	};


	/**
	 * promise cache
	 * @author vfasky <vfasky@gmail.com>
	 * @param key 缓存key
	 */

	exports.promiseCache = function(key, promise, options) {
	  var data, dtd;
	  data = options.proxy.get(key);
	  if (data) {
	    dtd = $.Deferred();
	    dtd.resolve(exports.clone(data));
	    return dtd.promise();
	  } else {
	    return promise().then(function(res) {
	      return options.proxy.set(key, exports.clone(res), options.time);
	    });
	  }
	};


	/**
	 * 基于本地存放的cache
	 * @author vfasky <vfasky@gmail.com>
	 *
	 */

	exports.promiseCacheLocalProxy = {
	  set: exports.cache.set,
	  get: exports.cache.get,
	  remove: exports.cache.remove
	};


	/**
	 * 基于内存的cache
	 * @author vfasky <vfasky@gmail.com>
	 *
	 */

	exports.promiseCacheMemoryproxy = {
	  set: function(key, value) {
	    return _memoryStorage[key] = value;
	  },
	  get: function(key) {
	    return _memoryStorage[key] || null;
	  },
	  remove: function(key) {
	    return delete _memoryStorage[key];
	  }
	};


	/**
	 * 遍历数组
	 */

	exports.each = function(arr, cb) {
	  var k, ref, v;
	  if (cb == null) {
	    cb = function() {};
	  }
	  if (false === Array.isArray(arr)) {
	    return;
	  }
	  for (k in arr) {
	    v = arr[k];
	    ref = cb(v, k);
	    if (false === ref) {
	      break;
	    }
	  }
	};

	exports.format = function(format) {
	  var arg, argIndex, args, c, escaped, i, n, nextArg, precision, result, slurpNumber;
	  argIndex = 1;
	  args = [].slice.call(arguments);
	  i = 0;
	  n = format.length;
	  result = '';
	  c = void 0;
	  escaped = false;
	  arg = void 0;
	  precision = void 0;
	  nextArg = function() {
	    return args[argIndex++];
	  };
	  slurpNumber = function() {
	    var digits;
	    digits = '';
	    while (format[i].match(/\d/)) {
	      digits += format[i++];
	    }
	    if (digits.length > 0) {
	      return parseInt(digits);
	    } else {
	      return null;
	    }
	  };
	  while (i < n) {
	    c = format[i];
	    if (escaped) {
	      escaped = false;
	      precision = slurpNumber();
	      switch (c) {
	        case 'b':
	          result += parseInt(nextArg(), 10).toString(2);
	          break;
	        case 'c':
	          arg = nextArg();
	          if (typeof arg === 'string' || arg instanceof String) {
	            result += arg;
	          } else {
	            result += String.fromCharCode(parseInt(arg, 10));
	          }
	          break;
	        case 'd':
	          result += parseInt(nextArg(), 10);
	          break;
	        case 'f':
	          result += parseFloat(nextArg()).toFixed(precision || 6);
	          break;
	        case 'o':
	          result += '0' + parseInt(nextArg(), 10).toString(8);
	          break;
	        case 's':
	          result += nextArg();
	          break;
	        case 'x':
	          result += '0x' + parseInt(nextArg(), 10).toString(16);
	          break;
	        case 'X':
	          result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();
	          break;
	        default:
	          result += c;
	          break;
	      }
	    } else if (c === '%') {
	      escaped = true;
	    } else {
	      result += c;
	    }
	    ++i;
	  }
	  return result;
	};


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * 路由
	 * @module mcore/route
	 * @author vfasky <vfasky@gmail.com>
	 * @example 
	 * route = new mcore.Route()
	 *
	 * route.add '/index/:id', (id)->
	 *     console.log id
	 *
	 * route.add '/show/*', (name)->
	 *     console.log name
	 * 
	 * route.add '/get/:id?', (id)->
	 *     console.log id # or undefined
	 * 
	 * route.add 'user user/:id', (id)->
	 *     console.log route.lookup('user', id:1) #/user/1
	 *
	 * route.run()
	 */
	"use strict";
	var Route, exports, pathToObject, pathToRegexp, util;

	util = __webpack_require__(1);


	/**
	 * 将路径转化为正则 
	 * @author vfasky <vfasky@gmail.com>
	 *
	 */

	pathToRegexp = function(path, keys, sensitive, strict) {
	  var toKeys;
	  if (keys == null) {
	    keys = [];
	  }
	  if (sensitive == null) {
	    sensitive = false;
	  }
	  if (strict == null) {
	    strict = false;
	  }
	  if (path instanceof RegExp) {
	    return path;
	  }
	  toKeys = function(_, slash, format, key, capture, optional) {
	    keys.push({
	      name: key,
	      optional: !!optional
	    });
	    slash = slash || '';
	    return '' + (optional && '' || slash) + '(?:' + (optional && slash || '') + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')' + (optional || '');
	  };
	  path = path.concat(strict && '' || '/?').replace(/\/\(/g, '(?:/').replace(/\+/g, '__plus__').replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g, toKeys).replace(/([\/.])/g, '\\$1').replace(/__plus__/g, '(.+)').replace(/\*/g, '(.*)');
	  return new RegExp('^' + path + '$', sensitive && '' || 'i');
	};


	/**
	 * 将 url 的参数转换为对象
	 * @author vfasky <vfasky@gmail.com>
	 *
	 */

	pathToObject = function(url) {
	  var argStr, args, attr, data, keys;
	  url = String(url);
	  argStr = '';
	  attr = [];
	  if (url.indexOf('?') !== -1) {
	    argStr = url.split('?').pop();
	  } else if (url.indexOf('&') !== -1) {
	    argStr = url;
	  }
	  if (argStr === '') {
	    return {};
	  }
	  args = argStr.split('&');
	  data = {};
	  keys = [];
	  args.forEach(function(v) {
	    var key, value;
	    if (v.indexOf('=') === -1) {
	      return;
	    }
	    v = v.split('=');
	    if (v.length !== 2) {
	      return;
	    }
	    key = v[0].trim();
	    value = v[1];
	    if (util.isNumber(value) && String(value).length < 14) {
	      value = Number(value);
	    } else {
	      value = decodeURIComponent(value);
	    }
	    data[key] = value;
	  });
	  return data;
	};


	/**
	 * 路由
	 * @author vfasky <vfasky@gmail.com>
	 *
	 */

	Route = function(hashchange, sensitive1, strict1) {
	  this.hashchange = hashchange != null ? hashchange : Route.changeByLocationHash;
	  this.sensitive = sensitive1 != null ? sensitive1 : false;
	  this.strict = strict1 != null ? strict1 : false;
	  this.rule = [];
	};


	/**
	 * 开始监听路由
	 * @author vfasky <vfasky@gmail.com>
	 *
	 */

	Route.prototype.run = function() {
	  this.hashchange((function(_this) {
	    return function(url) {
	      _this.match(url);
	    };
	  })(this));
	};


	/**
	 * 添加规则
	 * @author vfasky <vfasky@gmail.com>
	 *
	 */

	Route.prototype.add = function(path, fn) {
	  var keys, reg;
	  keys = [];
	  reg = pathToRegexp(path, keys, this.sensitive, this.strict);
	  this.rule.push({
	    path: path,
	    reg: reg,
	    keys: keys,
	    fn: fn
	  });
	  return this;
	};


	/**
	 * 配对 url
	 * @author vfasky <vfasky@gmail.com>
	 *
	 */

	Route.prototype.match = function(url) {
	  var argStr, fullPath, getIx, isMatch, path;
	  path = String(url);
	  fullPath = path;
	  argStr = '';
	  getIx = path.indexOf('?');
	  if (getIx === -1) {
	    getIx = path.indexOf('&');
	  }
	  isMatch = false;
	  if (getIx !== -1) {
	    argStr = path.substring(getIx);
	    path = path.substring(0, getIx);
	  }
	  util.each(this.rule, function(v) {
	    var args, context, data, env, i, j, k, ref, ref1, value;
	    if (isMatch) {
	      return false;
	    }
	    ref = v.reg.exec(path);
	    if (null === ref) {
	      return;
	    }
	    isMatch = true;
	    context = pathToObject(argStr);
	    data = {};
	    args = [];
	    for (i = j = 1, ref1 = ref.length; 1 <= ref1 ? j < ref1 : j > ref1; i = 1 <= ref1 ? ++j : --j) {
	      k = v.keys[i - 1];
	      value = ref[i];
	      if (util.isNumber(value) && String(value).length < 14) {
	        value = Number(value);
	      } else if (value) {
	        value = decodeURIComponent(value);
	      }
	      if (k && k.name) {
	        data[k.name] = value;
	      }
	      args.push(value || null);
	    }
	    env = {
	      url: fullPath,
	      path: path,
	      args: argStr,
	      rule: v.path,
	      context: context,
	      keys: v.keys,
	      data: data
	    };
	    v.fn.apply(env, args);
	  });
	  return this;
	};


	/**
	 * 通过 hashchange 触发
	 * @author vfasky <vfasky@gmail.com>
	 *
	 */

	Route.changeByLocationHash = function(emit) {
	  var hashChanged;
	  hashChanged = function() {
	    return emit(window.location.hash.substring(1));
	  };
	  if (window.addEventListener) {
	    window.addEventListener('hashchange', hashChanged, false);
	  } else {
	    window.attachEvent('onhashchange', hashChanged);
	  }
	  return hashChanged();
	};


	/*
	    通过 history api 触发
	    @author jackieLin <dashi_lin@163.com>
	 */

	Route.changeByHistory = function(emit) {
	  var historyChange;
	  if (!window.history) {
	    Route.changeByLocationHash(emit);
	  }
	  historyChange = function() {
	    return emit(window.location.hash.substring(1));
	  };
	  window.onpopstate = function(event) {
	    return historyChange();
	  };
	  return historyChange();
	};

	exports = module.exports = {
	  pathToRegexp: pathToRegexp,
	  pathToObject: pathToObject,
	  Route: Route
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * mcore config 
	 * @date 2015-11-11 09:27:25
	 * @author vfasky <vfasky@gmail.com>
	 * @link http://vfasky.com
	 * @version $Id$
	 */
	"use strict";
	var $, _config, exports, util;

	$ = __webpack_require__(4);

	util = __webpack_require__(1);

	_config = {
	  AMDLoader: window.requirejs
	};

	exports = module.exports = function(config) {
	  if (false === util.isObject(config)) {
	    return _config;
	  }
	  return _config = $.extend(_config, config);
	};


/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * 模板
	 * @module mcore/template
	 * @author vfasky <vfasky@gmail.com>
	 */
	"use strict";
	var $, Stapes, Template, config, exports, rivets, util,
	  slice = [].slice;

	$ = __webpack_require__(4);

	rivets = __webpack_require__(6);

	Stapes = __webpack_require__(9);

	util = __webpack_require__(1);

	config = __webpack_require__(3)();

	rivets.adapters[':'] = {
	  observe: function(obj, keypath, callback) {
	    obj.on('change:' + keypath, callback);
	  },
	  unobserve: function(obj, keypath, callback) {
	    obj.off('change:' + keypath, callback);
	  },
	  get: function(obj, keypath) {
	    return obj.get(keypath);
	  },
	  set: function(obj, keypath, value) {
	    obj.set(keypath, value);
	  }
	};

	rivets.configure({
	  rootInterface: '.',
	  handler: function(target, event, binding) {
	    var ref;
	    ref = this.call(binding.view.models.self, target, event);
	    if (false !== ref) {
	      return;
	    }
	    if (event.stopPropagation && event.preventDefault) {
	      event.stopPropagation();
	      return event.preventDefault();
	    } else {
	      window.event.cancelBubble = true;
	      return window.event.returnValue = false;
	    }
	  }
	});


	/**
	 * Formatters
	 */

	rivets.formatters['nl2br'] = function(value) {
	  if (!value) {
	    return '';
	  }
	  return String(value).trim().replace(/<[^>]+>/g, "").replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, '$1' + '<br/>' + '$2');
	};

	rivets.formatters['link'] = function(value, join) {
	  if (!value) {
	    return '';
	  }
	  return String(value) + String(join);
	};

	rivets.formatters['and'] = function(value, show) {
	  if (!value) {
	    return value;
	  }
	  return show;
	};

	rivets.formatters['or'] = function(value, show) {
	  if (value) {
	    return value;
	  }
	  return show;
	};

	rivets.formatters['slice'] = function(value, start, end) {
	  if (false === Array.isArray(value)) {
	    return [];
	  }
	  return value.slice(start, end);
	};

	rivets.formatters['substr'] = function(value, start, end) {
	  if (!value) {
	    return '';
	  }
	  return String(value).substring(start, end);
	};

	rivets.formatters['len'] = function(value) {
	  if (Array.isArray(value)) {
	    return value.length;
	  }
	  if (!value) {
	    return 0;
	  }
	  return String(value).length;
	};

	rivets.formatters['%'] = util.format;

	rivets.formatters['eq'] = function(value, x) {
	  return value === x;
	};

	rivets.formatters['<'] = function(value, x) {
	  return Number(value) < Number(x);
	};

	rivets.formatters['<='] = function(value, x) {
	  return Number(value) <= Number(x);
	};

	rivets.formatters['=='] = function(value, x) {
	  return Number(value) === Number(x);
	};

	rivets.formatters['>='] = function(value, x) {
	  return Number(value) >= Number(x);
	};

	rivets.formatters['>'] = function(value, x) {
	  return Number(value) > Number(x);
	};

	rivets.formatters['+'] = function(value, x) {
	  return Number(value) + Number(x);
	};

	rivets.formatters['-'] = function(value, x) {
	  return Number(value) - Number(x);
	};

	rivets.formatters['*'] = function(value, x) {
	  return Number(value) * Number(x);
	};

	rivets.formatters['/'] = function(value, x) {
	  return Number(value) / Number(x);
	};

	rivets.formatters['isArray'] = function(value) {
	  return Array.isArray(value);
	};

	rivets.formatters['eachObject'] = function(obj) {
	  var data, k, results, v;
	  if (false === util.isObject(obj)) {
	    return [];
	  }
	  data = [];
	  results = [];
	  for (k in obj) {
	    v = obj[k];
	    results.push(data.push({
	      key: k,
	      value: v
	    }));
	  }
	  return results;
	};

	rivets.formatters['toFixed'] = function(value, len) {
	  if (len == null) {
	    len = 1;
	  }
	  if (false === util.isNumber(value)) {
	    return 0;
	  }
	  return Number(value).toFixed(len);
	};

	rivets.formatters['in'] = function() {
	  var args, value;
	  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	  if (args.length < 2) {
	    return false;
	  }
	  value = args[0];
	  args.splice(0, 1);
	  if (util.isNumber(value)) {
	    value = Number(value);
	  }
	  return args.indexOf(value) !== -1;
	};


	/**
	 * 模板渲染
	 * @param {Object} view
	 * @param {jQuery} view.$el
	 * @param {Function} view.set
	 * @param {Object} data
	 */

	Template = function(view, data1) {
	  this.view = view;
	  this.data = data1 != null ? data1 : {};
	  this.rv = false;
	};

	Template.prototype.init = function() {
	  var data, dtd, keys, rv;
	  data = this.data;
	  keys = Object.keys(data);
	  dtd = $.Deferred();
	  if (keys.length === 0) {
	    rv = rivets.bind(this.view.$el, {
	      self: this.view
	    });
	    this.rv = rv;
	    dtd.resolve(rv);
	  } else {
	    Template.loadPromise(data).done((function(_this) {
	      return function(vData) {
	        keys.forEach(function(k) {
	          var v;
	          v = vData[k];
	          if (v != null) {
	            return _this.view.set(k, v);
	          }
	        });
	        rv = rivets.bind(_this.view.$el, {
	          self: _this.view
	        });
	        _this.rv = rv;
	        dtd.resolve(rv);
	      };
	    })(this)).fail(function() {
	      return dtd.reject('template render error');
	    });
	  }
	  return dtd.promise();
	};

	Template.prototype.set = function(key, promise) {
	  return promise.then((function(_this) {
	    return function(val) {
	      return _this.view.set(key, val);
	    };
	  })(this));
	};

	Template.prototype.update = function(data) {
	  var dtd, keys;
	  if (data == null) {
	    data = {};
	  }
	  dtd = $.Deferred();
	  if (false === this.rv) {
	    dtd.reject('Template no init');
	  } else {
	    keys = Object.keys(data);
	    Template.loadPromise(data).done((function(_this) {
	      return function(vData) {
	        var newData;
	        newData = {};
	        keys.forEach(function(k) {
	          var v;
	          v = vData[k];
	          if (v != null) {
	            return newData[k] = v;
	          }
	        });
	        _this.view.set(newData);
	        dtd.resolve(vData);
	      };
	    })(this)).fail(function() {
	      return dtd.reject('template update error');
	    });
	  }
	  return dtd.promise();
	};

	Template.prototype.destroy = function() {
	  if (this.rv) {
	    return this.rv.unbind();
	  }
	};

	Template.loadPromise = function(data) {
	  var dtd, keys, promises;
	  dtd = $.Deferred();
	  keys = Object.keys(data);
	  if (keys.length === 0) {
	    dtd.resolve({});
	  } else {
	    promises = [];
	    keys.forEach((function(_this) {
	      return function(v) {
	        return promises.push(data[v]);
	      };
	    })(this));
	    $.when.apply(null, promises).done(function() {
	      var args, vData;
	      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	      vData = {};
	      args.forEach((function(_this) {
	        return function(v, k) {
	          var key;
	          key = keys[k];
	          if (key) {
	            if (Array.isArray(v) && v.length === 3 && v[2].promise) {
	              v = v[0];
	            }
	            return vData[key] = v;
	          }
	        };
	      })(this));
	      return dtd.resolve(vData);
	    }).fail(function(err) {
	      console.log(err);
	      return dtd.reject(err);
	    });
	  }
	  return dtd.promise();
	};


	/**
	 * 加载amd规范的模板，
	 * 包名必须为 tpl/ 前缀
	 */

	Template.loadTpl = function(uri) {
	  var dtd, info;
	  dtd = $.Deferred();
	  info = String(uri).split('/');
	  if (info.length === 2) {
	    config.AMDLoader(["tpl/" + info[0]], function(tpl) {
	      var html;
	      html = tpl[info[1]];
	      if (html) {
	        return dtd.resolve(html);
	      } else {
	        return dtd.reject('url data map error');
	      }
	    });
	  } else {
	    dtd.reject('uri error: ' + uri);
	  }
	  return dtd.promise();
	};

	Template.bind = function(data, model) {
	  if (data == null) {
	    data = {};
	  }
	  model.tpl = new Template(model, data);
	  return model.tpl.init().then(function() {
	    model.emit('render');
	    return model.tpl;
	  });
	};

	Template.renderString = function(html, data, model) {
	  var defTplVal, keys;
	  if (data == null) {
	    data = {};
	  }
	  keys = Object.keys(data);
	  if (keys.length > 0 && !model.tpl) {
	    defTplVal = {};
	    keys.forEach((function(_this) {
	      return function(k) {
	        return defTplVal[k] = {};
	      };
	    })(this));
	    model.set(defTplVal);
	  }
	  if (model.tpl) {
	    model.emit('tplBeforeUpdate');
	    return model.tpl.update(data).then(function() {
	      model.emit('tplUpdate');
	      return model.tpl;
	    });
	  } else {
	    model.$el.hide().append(html);
	    model.emit('beforeRender');
	    return Template.bind(data, model).then(function(res) {
	      model.$el.show();
	      return res;
	    });
	  }
	};

	Template.render = function(uri, data, model) {
	  if (data == null) {
	    data = {};
	  }
	  return Template.loadTpl(uri).then(function(html) {
	    return Template.renderString(html, data, model);
	  });
	};

	Template.formatters = function(name, fun) {
	  return rivets.formatters[name] = fun;
	};

	Template.Attr = Stapes.subclass({
	  constructor: function(name1, rv1, el1) {
	    this.name = name1;
	    this.rv = rv1;
	    this.el = el1;
	    this.$el = $(this.el);
	    this.init(this.el);
	    return this.watch();
	  },
	  sync: function(value) {
	    return this.rv.observer.setValue(value);
	  },
	  init: function(el) {},
	  update: function(value, el) {},
	  destroy: function(el) {},
	  watch: function() {}
	});

	Template.regAttr = function(name, Attr) {
	  var attr;
	  attr = null;
	  return rivets.binders[name] = {
	    bind: function(el) {
	      return attr = new Attr(name, this, el);
	    },
	    unbind: function(el) {
	      return attr.destroy(el);
	    },
	    routine: function(el, value) {
	      return attr.update(value, el);
	    }
	  };
	};

	Template.regTag = function(name, options) {
	  if (options == null) {
	    options = {};
	  }
	  return rivets.components[name] = {
	    "static": options["static"] || [],
	    attributes: options.attr || [],
	    template: options.template || function() {
	      return '';
	    },
	    initialize: options.init || function() {}
	  };
	};

	exports = module.exports = Template;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {// Rivets.js
	// version: 0.8.1
	// author: Michael Richards
	// license: MIT
	(function() {
	  var Rivets, bindMethod, unbindMethod, _ref,
	    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    __slice = [].slice,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	  Rivets = {
	    options: ['prefix', 'templateDelimiters', 'rootInterface', 'preloadData', 'handler'],
	    extensions: ['binders', 'formatters', 'components', 'adapters'],
	    "public": {
	      binders: {},
	      components: {},
	      formatters: {},
	      adapters: {},
	      prefix: 'rv',
	      templateDelimiters: ['{', '}'],
	      rootInterface: '.',
	      preloadData: true,
	      handler: function(context, ev, binding) {
	        return this.call(context, ev, binding.view.models);
	      },
	      configure: function(options) {
	        var descriptor, key, option, value;
	        if (options == null) {
	          options = {};
	        }
	        for (option in options) {
	          value = options[option];
	          if (option === 'binders' || option === 'components' || option === 'formatters' || option === 'adapters') {
	            for (key in value) {
	              descriptor = value[key];
	              Rivets[option][key] = descriptor;
	            }
	          } else {
	            Rivets["public"][option] = value;
	          }
	        }
	      },
	      bind: function(el, models, options) {
	        var view;
	        if (models == null) {
	          models = {};
	        }
	        if (options == null) {
	          options = {};
	        }
	        view = new Rivets.View(el, models, options);
	        view.bind();
	        return view;
	      },
	      init: function(component, el, data) {
	        var scope, view;
	        if (data == null) {
	          data = {};
	        }
	        if (el == null) {
	          el = document.createElement('div');
	        }
	        component = Rivets["public"].components[component];
	        el.innerHTML = component.template.call(this, el);
	        scope = component.initialize.call(this, el, data);
	        view = new Rivets.View(el, scope);
	        view.bind();
	        return view;
	      }
	    }
	  };

	  if (window['jQuery'] || window['$']) {
	    _ref = 'on' in jQuery.prototype ? ['on', 'off'] : ['bind', 'unbind'], bindMethod = _ref[0], unbindMethod = _ref[1];
	    Rivets.Util = {
	      bindEvent: function(el, event, handler) {
	        return jQuery(el)[bindMethod](event, handler);
	      },
	      unbindEvent: function(el, event, handler) {
	        return jQuery(el)[unbindMethod](event, handler);
	      },
	      getInputValue: function(el) {
	        var $el;
	        $el = jQuery(el);
	        if ($el.attr('type') === 'checkbox') {
	          return $el.is(':checked');
	        } else {
	          return $el.val();
	        }
	      }
	    };
	  } else {
	    Rivets.Util = {
	      bindEvent: (function() {
	        if ('addEventListener' in window) {
	          return function(el, event, handler) {
	            return el.addEventListener(event, handler, false);
	          };
	        }
	        return function(el, event, handler) {
	          return el.attachEvent('on' + event, handler);
	        };
	      })(),
	      unbindEvent: (function() {
	        if ('removeEventListener' in window) {
	          return function(el, event, handler) {
	            return el.removeEventListener(event, handler, false);
	          };
	        }
	        return function(el, event, handler) {
	          return el.detachEvent('on' + event, handler);
	        };
	      })(),
	      getInputValue: function(el) {
	        var o, _i, _len, _results;
	        if (el.type === 'checkbox') {
	          return el.checked;
	        } else if (el.type === 'select-multiple') {
	          _results = [];
	          for (_i = 0, _len = el.length; _i < _len; _i++) {
	            o = el[_i];
	            if (o.selected) {
	              _results.push(o.value);
	            }
	          }
	          return _results;
	        } else {
	          return el.value;
	        }
	      }
	    };
	  }

	  Rivets.TypeParser = (function() {
	    function TypeParser() {}

	    TypeParser.types = {
	      primitive: 0,
	      keypath: 1
	    };

	    TypeParser.parse = function(string) {
	      if (/^'.*'$|^".*"$/.test(string)) {
	        return {
	          type: this.types.primitive,
	          value: string.slice(1, -1)
	        };
	      } else if (string === 'true') {
	        return {
	          type: this.types.primitive,
	          value: true
	        };
	      } else if (string === 'false') {
	        return {
	          type: this.types.primitive,
	          value: false
	        };
	      } else if (string === 'null') {
	        return {
	          type: this.types.primitive,
	          value: null
	        };
	      } else if (string === 'undefined') {
	        return {
	          type: this.types.primitive,
	          value: void 0
	        };
	      } else if (isNaN(Number(string)) === false) {
	        return {
	          type: this.types.primitive,
	          value: Number(string)
	        };
	      } else {
	        return {
	          type: this.types.keypath,
	          value: string
	        };
	      }
	    };

	    return TypeParser;

	  })();

	  Rivets.TextTemplateParser = (function() {
	    function TextTemplateParser() {}

	    TextTemplateParser.types = {
	      text: 0,
	      binding: 1
	    };

	    TextTemplateParser.parse = function(template, delimiters) {
	      var index, lastIndex, lastToken, length, substring, tokens, value;
	      tokens = [];
	      length = template.length;
	      index = 0;
	      lastIndex = 0;
	      while (lastIndex < length) {
	        index = template.indexOf(delimiters[0], lastIndex);
	        if (index < 0) {
	          tokens.push({
	            type: this.types.text,
	            value: template.slice(lastIndex)
	          });
	          break;
	        } else {
	          if (index > 0 && lastIndex < index) {
	            tokens.push({
	              type: this.types.text,
	              value: template.slice(lastIndex, index)
	            });
	          }
	          lastIndex = index + delimiters[0].length;
	          index = template.indexOf(delimiters[1], lastIndex);
	          if (index < 0) {
	            substring = template.slice(lastIndex - delimiters[1].length);
	            lastToken = tokens[tokens.length - 1];
	            if ((lastToken != null ? lastToken.type : void 0) === this.types.text) {
	              lastToken.value += substring;
	            } else {
	              tokens.push({
	                type: this.types.text,
	                value: substring
	              });
	            }
	            break;
	          }
	          value = template.slice(lastIndex, index).trim();
	          tokens.push({
	            type: this.types.binding,
	            value: value
	          });
	          lastIndex = index + delimiters[1].length;
	        }
	      }
	      return tokens;
	    };

	    return TextTemplateParser;

	  })();

	  Rivets.View = (function() {
	    function View(els, models, options) {
	      var k, option, v, _base, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5;
	      this.els = els;
	      this.models = models;
	      if (options == null) {
	        options = {};
	      }
	      this.update = __bind(this.update, this);
	      this.publish = __bind(this.publish, this);
	      this.sync = __bind(this.sync, this);
	      this.unbind = __bind(this.unbind, this);
	      this.bind = __bind(this.bind, this);
	      this.select = __bind(this.select, this);
	      this.traverse = __bind(this.traverse, this);
	      this.build = __bind(this.build, this);
	      this.buildBinding = __bind(this.buildBinding, this);
	      this.bindingRegExp = __bind(this.bindingRegExp, this);
	      this.options = __bind(this.options, this);
	      if (!(this.els.jquery || this.els instanceof Array)) {
	        this.els = [this.els];
	      }
	      _ref1 = Rivets.extensions;
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        option = _ref1[_i];
	        this[option] = {};
	        if (options[option]) {
	          _ref2 = options[option];
	          for (k in _ref2) {
	            v = _ref2[k];
	            this[option][k] = v;
	          }
	        }
	        _ref3 = Rivets["public"][option];
	        for (k in _ref3) {
	          v = _ref3[k];
	          if ((_base = this[option])[k] == null) {
	            _base[k] = v;
	          }
	        }
	      }
	      _ref4 = Rivets.options;
	      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
	        option = _ref4[_j];
	        this[option] = (_ref5 = options[option]) != null ? _ref5 : Rivets["public"][option];
	      }
	      this.build();
	    }

	    View.prototype.options = function() {
	      var option, options, _i, _len, _ref1;
	      options = {};
	      _ref1 = Rivets.extensions.concat(Rivets.options);
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        option = _ref1[_i];
	        options[option] = this[option];
	      }
	      return options;
	    };

	    View.prototype.bindingRegExp = function() {
	      return new RegExp("^" + this.prefix + "-");
	    };

	    View.prototype.buildBinding = function(binding, node, type, declaration) {
	      var context, ctx, dependencies, keypath, options, pipe, pipes;
	      options = {};
	      pipes = (function() {
	        var _i, _len, _ref1, _results;
	        _ref1 = declaration.split('|');
	        _results = [];
	        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	          pipe = _ref1[_i];
	          _results.push(pipe.trim());
	        }
	        return _results;
	      })();
	      context = (function() {
	        var _i, _len, _ref1, _results;
	        _ref1 = pipes.shift().split('<');
	        _results = [];
	        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	          ctx = _ref1[_i];
	          _results.push(ctx.trim());
	        }
	        return _results;
	      })();
	      keypath = context.shift();
	      options.formatters = pipes;
	      if (dependencies = context.shift()) {
	        options.dependencies = dependencies.split(/\s+/);
	      }
	      return this.bindings.push(new Rivets[binding](this, node, type, keypath, options));
	    };

	    View.prototype.build = function() {
	      var el, parse, _i, _len, _ref1;
	      this.bindings = [];
	      parse = (function(_this) {
	        return function(node) {
	          var block, childNode, delimiters, n, parser, text, token, tokens, _i, _j, _len, _len1, _ref1, _results;
	          if (node.nodeType === 3) {
	            parser = Rivets.TextTemplateParser;
	            if (delimiters = _this.templateDelimiters) {
	              if ((tokens = parser.parse(node.data, delimiters)).length) {
	                if (!(tokens.length === 1 && tokens[0].type === parser.types.text)) {
	                  for (_i = 0, _len = tokens.length; _i < _len; _i++) {
	                    token = tokens[_i];
	                    text = document.createTextNode(token.value);
	                    node.parentNode.insertBefore(text, node);
	                    if (token.type === 1) {
	                      _this.buildBinding('TextBinding', text, null, token.value);
	                    }
	                  }
	                  node.parentNode.removeChild(node);
	                }
	              }
	            }
	          } else if (node.nodeType === 1) {
	            block = _this.traverse(node);
	          }
	          if (!block) {
	            _ref1 = (function() {
	              var _k, _len1, _ref1, _results1;
	              _ref1 = node.childNodes;
	              _results1 = [];
	              for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
	                n = _ref1[_k];
	                _results1.push(n);
	              }
	              return _results1;
	            })();
	            _results = [];
	            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
	              childNode = _ref1[_j];
	              _results.push(parse(childNode));
	            }
	            return _results;
	          }
	        };
	      })(this);
	      _ref1 = this.els;
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        el = _ref1[_i];
	        parse(el);
	      }
	      this.bindings.sort(function(a, b) {
	        var _ref2, _ref3;
	        return (((_ref2 = b.binder) != null ? _ref2.priority : void 0) || 0) - (((_ref3 = a.binder) != null ? _ref3.priority : void 0) || 0);
	      });
	    };

	    View.prototype.traverse = function(node) {
	      var attribute, attributes, binder, bindingRegExp, block, identifier, regexp, type, value, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
	      bindingRegExp = this.bindingRegExp();
	      block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE';
	      _ref1 = node.attributes;
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        attribute = _ref1[_i];
	        if (bindingRegExp.test(attribute.name)) {
	          type = attribute.name.replace(bindingRegExp, '');
	          if (!(binder = this.binders[type])) {
	            _ref2 = this.binders;
	            for (identifier in _ref2) {
	              value = _ref2[identifier];
	              if (identifier !== '*' && identifier.indexOf('*') !== -1) {
	                regexp = new RegExp("^" + (identifier.replace(/\*/g, '.+')) + "$");
	                if (regexp.test(type)) {
	                  binder = value;
	                }
	              }
	            }
	          }
	          binder || (binder = this.binders['*']);
	          if (binder.block) {
	            block = true;
	            attributes = [attribute];
	          }
	        }
	      }
	      _ref3 = attributes || node.attributes;
	      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
	        attribute = _ref3[_j];
	        if (bindingRegExp.test(attribute.name)) {
	          type = attribute.name.replace(bindingRegExp, '');
	          this.buildBinding('Binding', node, type, attribute.value);
	        }
	      }
	      if (!block) {
	        type = node.nodeName.toLowerCase();
	        if (this.components[type] && !node._bound) {
	          this.bindings.push(new Rivets.ComponentBinding(this, node, type));
	          block = true;
	        }
	      }
	      return block;
	    };

	    View.prototype.select = function(fn) {
	      var binding, _i, _len, _ref1, _results;
	      _ref1 = this.bindings;
	      _results = [];
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        binding = _ref1[_i];
	        if (fn(binding)) {
	          _results.push(binding);
	        }
	      }
	      return _results;
	    };

	    View.prototype.bind = function() {
	      var binding, _i, _len, _ref1, _results;
	      _ref1 = this.bindings;
	      _results = [];
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        binding = _ref1[_i];
	        _results.push(binding.bind());
	      }
	      return _results;
	    };

	    View.prototype.unbind = function() {
	      var binding, _i, _len, _ref1, _results;
	      _ref1 = this.bindings;
	      _results = [];
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        binding = _ref1[_i];
	        _results.push(binding.unbind());
	      }
	      return _results;
	    };

	    View.prototype.sync = function() {
	      var binding, _i, _len, _ref1, _results;
	      _ref1 = this.bindings;
	      _results = [];
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        binding = _ref1[_i];
	        _results.push(typeof binding.sync === "function" ? binding.sync() : void 0);
	      }
	      return _results;
	    };

	    View.prototype.publish = function() {
	      var binding, _i, _len, _ref1, _results;
	      _ref1 = this.select(function(b) {
	        var _ref1;
	        return (_ref1 = b.binder) != null ? _ref1.publishes : void 0;
	      });
	      _results = [];
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        binding = _ref1[_i];
	        _results.push(binding.publish());
	      }
	      return _results;
	    };

	    View.prototype.update = function(models) {
	      var binding, key, model, _i, _len, _ref1, _results;
	      if (models == null) {
	        models = {};
	      }
	      for (key in models) {
	        model = models[key];
	        this.models[key] = model;
	      }
	      _ref1 = this.bindings;
	      _results = [];
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        binding = _ref1[_i];
	        _results.push(typeof binding.update === "function" ? binding.update(models) : void 0);
	      }
	      return _results;
	    };

	    return View;

	  })();

	  Rivets.Binding = (function() {
	    function Binding(view, el, type, keypath, options) {
	      this.view = view;
	      this.el = el;
	      this.type = type;
	      this.keypath = keypath;
	      this.options = options != null ? options : {};
	      this.getValue = __bind(this.getValue, this);
	      this.update = __bind(this.update, this);
	      this.unbind = __bind(this.unbind, this);
	      this.bind = __bind(this.bind, this);
	      this.publish = __bind(this.publish, this);
	      this.sync = __bind(this.sync, this);
	      this.set = __bind(this.set, this);
	      this.eventHandler = __bind(this.eventHandler, this);
	      this.formattedValue = __bind(this.formattedValue, this);
	      this.parseTarget = __bind(this.parseTarget, this);
	      this.observe = __bind(this.observe, this);
	      this.setBinder = __bind(this.setBinder, this);
	      this.formatters = this.options.formatters || [];
	      this.dependencies = [];
	      this.formatterObservers = {};
	      this.model = void 0;
	      this.setBinder();
	    }

	    Binding.prototype.setBinder = function() {
	      var identifier, regexp, value, _ref1;
	      if (!(this.binder = this.view.binders[this.type])) {
	        _ref1 = this.view.binders;
	        for (identifier in _ref1) {
	          value = _ref1[identifier];
	          if (identifier !== '*' && identifier.indexOf('*') !== -1) {
	            regexp = new RegExp("^" + (identifier.replace(/\*/g, '.+')) + "$");
	            if (regexp.test(this.type)) {
	              this.binder = value;
	              this.args = new RegExp("^" + (identifier.replace(/\*/g, '(.+)')) + "$").exec(this.type);
	              this.args.shift();
	            }
	          }
	        }
	      }
	      this.binder || (this.binder = this.view.binders['*']);
	      if (this.binder instanceof Function) {
	        return this.binder = {
	          routine: this.binder
	        };
	      }
	    };

	    Binding.prototype.observe = function(obj, keypath, callback) {
	      return Rivets.sightglass(obj, keypath, callback, {
	        root: this.view.rootInterface,
	        adapters: this.view.adapters
	      });
	    };

	    Binding.prototype.parseTarget = function() {
	      var token;
	      token = Rivets.TypeParser.parse(this.keypath);
	      if (token.type === 0) {
	        return this.value = token.value;
	      } else {
	        this.observer = this.observe(this.view.models, this.keypath, this.sync);
	        return this.model = this.observer.target;
	      }
	    };

	    Binding.prototype.formattedValue = function(value) {
	      var ai, arg, args, fi, formatter, id, observer, processedArgs, _base, _i, _j, _len, _len1, _ref1;
	      _ref1 = this.formatters;
	      for (fi = _i = 0, _len = _ref1.length; _i < _len; fi = ++_i) {
	        formatter = _ref1[fi];
	        args = formatter.match(/[^\s']+|'([^']|'[^\s])*'|"([^"]|"[^\s])*"/g);
	        id = args.shift();
	        formatter = this.view.formatters[id];
	        args = (function() {
	          var _j, _len1, _results;
	          _results = [];
	          for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
	            arg = args[_j];
	            _results.push(Rivets.TypeParser.parse(arg));
	          }
	          return _results;
	        })();
	        processedArgs = [];
	        for (ai = _j = 0, _len1 = args.length; _j < _len1; ai = ++_j) {
	          arg = args[ai];
	          processedArgs.push(arg.type === 0 ? arg.value : ((_base = this.formatterObservers)[fi] || (_base[fi] = {}), !(observer = this.formatterObservers[fi][ai]) ? (observer = this.observe(this.view.models, arg.value, this.sync), this.formatterObservers[fi][ai] = observer) : void 0, observer.value()));
	        }
	        if ((formatter != null ? formatter.read : void 0) instanceof Function) {
	          value = formatter.read.apply(formatter, [value].concat(__slice.call(processedArgs)));
	        } else if (formatter instanceof Function) {
	          value = formatter.apply(null, [value].concat(__slice.call(processedArgs)));
	        }
	      }
	      return value;
	    };

	    Binding.prototype.eventHandler = function(fn) {
	      var binding, handler;
	      handler = (binding = this).view.handler;
	      return function(ev) {
	        return handler.call(fn, this, ev, binding);
	      };
	    };

	    Binding.prototype.set = function(value) {
	      var _ref1;
	      value = value instanceof Function && !this.binder["function"] ? this.formattedValue(value.call(this.model)) : this.formattedValue(value);
	      return (_ref1 = this.binder.routine) != null ? _ref1.call(this, this.el, value) : void 0;
	    };

	    Binding.prototype.sync = function() {
	      var dependency, observer;
	      return this.set((function() {
	        var _i, _j, _len, _len1, _ref1, _ref2, _ref3;
	        if (this.observer) {
	          if (this.model !== this.observer.target) {
	            _ref1 = this.dependencies;
	            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	              observer = _ref1[_i];
	              observer.unobserve();
	            }
	            this.dependencies = [];
	            if (((this.model = this.observer.target) != null) && ((_ref2 = this.options.dependencies) != null ? _ref2.length : void 0)) {
	              _ref3 = this.options.dependencies;
	              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
	                dependency = _ref3[_j];
	                observer = this.observe(this.model, dependency, this.sync);
	                this.dependencies.push(observer);
	              }
	            }
	          }
	          return this.observer.value();
	        } else {
	          return this.value;
	        }
	      }).call(this));
	    };

	    Binding.prototype.publish = function() {
	      var args, formatter, id, value, _i, _len, _ref1, _ref2, _ref3;
	      if (this.observer) {
	        value = this.getValue(this.el);
	        _ref1 = this.formatters.slice(0).reverse();
	        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	          formatter = _ref1[_i];
	          args = formatter.split(/\s+/);
	          id = args.shift();
	          if ((_ref2 = this.view.formatters[id]) != null ? _ref2.publish : void 0) {
	            value = (_ref3 = this.view.formatters[id]).publish.apply(_ref3, [value].concat(__slice.call(args)));
	          }
	        }
	        return this.observer.setValue(value);
	      }
	    };

	    Binding.prototype.bind = function() {
	      var dependency, observer, _i, _len, _ref1, _ref2, _ref3;
	      this.parseTarget();
	      if ((_ref1 = this.binder.bind) != null) {
	        _ref1.call(this, this.el);
	      }
	      if ((this.model != null) && ((_ref2 = this.options.dependencies) != null ? _ref2.length : void 0)) {
	        _ref3 = this.options.dependencies;
	        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
	          dependency = _ref3[_i];
	          observer = this.observe(this.model, dependency, this.sync);
	          this.dependencies.push(observer);
	        }
	      }
	      if (this.view.preloadData) {
	        return this.sync();
	      }
	    };

	    Binding.prototype.unbind = function() {
	      var ai, args, fi, observer, _i, _len, _ref1, _ref2, _ref3, _ref4;
	      if ((_ref1 = this.binder.unbind) != null) {
	        _ref1.call(this, this.el);
	      }
	      if ((_ref2 = this.observer) != null) {
	        _ref2.unobserve();
	      }
	      _ref3 = this.dependencies;
	      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
	        observer = _ref3[_i];
	        observer.unobserve();
	      }
	      this.dependencies = [];
	      _ref4 = this.formatterObservers;
	      for (fi in _ref4) {
	        args = _ref4[fi];
	        for (ai in args) {
	          observer = args[ai];
	          observer.unobserve();
	        }
	      }
	      return this.formatterObservers = {};
	    };

	    Binding.prototype.update = function(models) {
	      var _ref1, _ref2;
	      if (models == null) {
	        models = {};
	      }
	      this.model = (_ref1 = this.observer) != null ? _ref1.target : void 0;
	      return (_ref2 = this.binder.update) != null ? _ref2.call(this, models) : void 0;
	    };

	    Binding.prototype.getValue = function(el) {
	      if (this.binder && (this.binder.getValue != null)) {
	        return this.binder.getValue.call(this, el);
	      } else {
	        return Rivets.Util.getInputValue(el);
	      }
	    };

	    return Binding;

	  })();

	  Rivets.ComponentBinding = (function(_super) {
	    __extends(ComponentBinding, _super);

	    function ComponentBinding(view, el, type) {
	      var attribute, bindingRegExp, propertyName, _i, _len, _ref1, _ref2;
	      this.view = view;
	      this.el = el;
	      this.type = type;
	      this.unbind = __bind(this.unbind, this);
	      this.bind = __bind(this.bind, this);
	      this.locals = __bind(this.locals, this);
	      this.component = this.view.components[this.type];
	      this["static"] = {};
	      this.observers = {};
	      this.upstreamObservers = {};
	      bindingRegExp = view.bindingRegExp();
	      _ref1 = this.el.attributes || [];
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        attribute = _ref1[_i];
	        if (!bindingRegExp.test(attribute.name)) {
	          propertyName = this.camelCase(attribute.name);
	          if (__indexOf.call((_ref2 = this.component["static"]) != null ? _ref2 : [], propertyName) >= 0) {
	            this["static"][propertyName] = attribute.value;
	          } else {
	            this.observers[propertyName] = attribute.value;
	          }
	        }
	      }
	    }

	    ComponentBinding.prototype.sync = function() {};

	    ComponentBinding.prototype.update = function() {};

	    ComponentBinding.prototype.publish = function() {};

	    ComponentBinding.prototype.locals = function() {
	      var key, observer, result, value, _ref1, _ref2;
	      result = {};
	      _ref1 = this["static"];
	      for (key in _ref1) {
	        value = _ref1[key];
	        result[key] = value;
	      }
	      _ref2 = this.observers;
	      for (key in _ref2) {
	        observer = _ref2[key];
	        result[key] = observer.value();
	      }
	      return result;
	    };

	    ComponentBinding.prototype.camelCase = function(string) {
	      return string.replace(/-([a-z])/g, function(grouped) {
	        return grouped[1].toUpperCase();
	      });
	    };

	    ComponentBinding.prototype.bind = function() {
	      var k, key, keypath, observer, option, options, scope, v, _base, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _results;
	      if (!this.bound) {
	        _ref1 = this.observers;
	        for (key in _ref1) {
	          keypath = _ref1[key];
	          this.observers[key] = this.observe(this.view.models, keypath, ((function(_this) {
	            return function(key) {
	              return function() {
	                return _this.componentView.models[key] = _this.observers[key].value();
	              };
	            };
	          })(this)).call(this, key));
	        }
	        this.bound = true;
	      }
	      if (this.componentView != null) {
	        return this.componentView.bind();
	      } else {
	        this.el.innerHTML = this.component.template.call(this);
	        scope = this.component.initialize.call(this, this.el, this.locals());
	        this.el._bound = true;
	        options = {};
	        _ref2 = Rivets.extensions;
	        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
	          option = _ref2[_i];
	          options[option] = {};
	          if (this.component[option]) {
	            _ref3 = this.component[option];
	            for (k in _ref3) {
	              v = _ref3[k];
	              options[option][k] = v;
	            }
	          }
	          _ref4 = this.view[option];
	          for (k in _ref4) {
	            v = _ref4[k];
	            if ((_base = options[option])[k] == null) {
	              _base[k] = v;
	            }
	          }
	        }
	        _ref5 = Rivets.options;
	        for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
	          option = _ref5[_j];
	          options[option] = (_ref6 = this.component[option]) != null ? _ref6 : this.view[option];
	        }
	        this.componentView = new Rivets.View(this.el, scope, options);
	        this.componentView.bind();
	        _ref7 = this.observers;
	        _results = [];
	        for (key in _ref7) {
	          observer = _ref7[key];
	          _results.push(this.upstreamObservers[key] = this.observe(this.componentView.models, key, ((function(_this) {
	            return function(key, observer) {
	              return function() {
	                return observer.setValue(_this.componentView.models[key]);
	              };
	            };
	          })(this)).call(this, key, observer)));
	        }
	        return _results;
	      }
	    };

	    ComponentBinding.prototype.unbind = function() {
	      var key, observer, _ref1, _ref2, _ref3;
	      _ref1 = this.upstreamObservers;
	      for (key in _ref1) {
	        observer = _ref1[key];
	        observer.unobserve();
	      }
	      _ref2 = this.observers;
	      for (key in _ref2) {
	        observer = _ref2[key];
	        observer.unobserve();
	      }
	      return (_ref3 = this.componentView) != null ? _ref3.unbind.call(this) : void 0;
	    };

	    return ComponentBinding;

	  })(Rivets.Binding);

	  Rivets.TextBinding = (function(_super) {
	    __extends(TextBinding, _super);

	    function TextBinding(view, el, type, keypath, options) {
	      this.view = view;
	      this.el = el;
	      this.type = type;
	      this.keypath = keypath;
	      this.options = options != null ? options : {};
	      this.sync = __bind(this.sync, this);
	      this.formatters = this.options.formatters || [];
	      this.dependencies = [];
	      this.formatterObservers = {};
	    }

	    TextBinding.prototype.binder = {
	      routine: function(node, value) {
	        return node.data = value != null ? value : '';
	      }
	    };

	    TextBinding.prototype.sync = function() {
	      return TextBinding.__super__.sync.apply(this, arguments);
	    };

	    return TextBinding;

	  })(Rivets.Binding);

	  Rivets["public"].binders.text = function(el, value) {
	    if (el.textContent != null) {
	      return el.textContent = value != null ? value : '';
	    } else {
	      return el.innerText = value != null ? value : '';
	    }
	  };

	  Rivets["public"].binders.html = function(el, value) {
	    return el.innerHTML = value != null ? value : '';
	  };

	  Rivets["public"].binders.show = function(el, value) {
	    return el.style.display = value ? '' : 'none';
	  };

	  Rivets["public"].binders.hide = function(el, value) {
	    return el.style.display = value ? 'none' : '';
	  };

	  Rivets["public"].binders.enabled = function(el, value) {
	    return el.disabled = !value;
	  };

	  Rivets["public"].binders.disabled = function(el, value) {
	    return el.disabled = !!value;
	  };

	  Rivets["public"].binders.checked = {
	    publishes: true,
	    priority: 2000,
	    bind: function(el) {
	      return Rivets.Util.bindEvent(el, 'change', this.publish);
	    },
	    unbind: function(el) {
	      return Rivets.Util.unbindEvent(el, 'change', this.publish);
	    },
	    routine: function(el, value) {
	      var _ref1;
	      if (el.type === 'radio') {
	        return el.checked = ((_ref1 = el.value) != null ? _ref1.toString() : void 0) === (value != null ? value.toString() : void 0);
	      } else {
	        return el.checked = !!value;
	      }
	    }
	  };

	  Rivets["public"].binders.unchecked = {
	    publishes: true,
	    priority: 2000,
	    bind: function(el) {
	      return Rivets.Util.bindEvent(el, 'change', this.publish);
	    },
	    unbind: function(el) {
	      return Rivets.Util.unbindEvent(el, 'change', this.publish);
	    },
	    routine: function(el, value) {
	      var _ref1;
	      if (el.type === 'radio') {
	        return el.checked = ((_ref1 = el.value) != null ? _ref1.toString() : void 0) !== (value != null ? value.toString() : void 0);
	      } else {
	        return el.checked = !value;
	      }
	    }
	  };

	  Rivets["public"].binders.value = {
	    publishes: true,
	    priority: 3000,
	    bind: function(el) {
	      if (!(el.tagName === 'INPUT' && el.type === 'radio')) {
	        this.event = el.tagName === 'SELECT' ? 'change' : 'input';
	        return Rivets.Util.bindEvent(el, this.event, this.publish);
	      }
	    },
	    unbind: function(el) {
	      if (!(el.tagName === 'INPUT' && el.type === 'radio')) {
	        return Rivets.Util.unbindEvent(el, this.event, this.publish);
	      }
	    },
	    routine: function(el, value) {
	      var o, _i, _len, _ref1, _ref2, _ref3, _results;
	      if (el.tagName === 'INPUT' && el.type === 'radio') {
	        return el.setAttribute('value', value);
	      } else if (window.jQuery != null) {
	        el = jQuery(el);
	        if ((value != null ? value.toString() : void 0) !== ((_ref1 = el.val()) != null ? _ref1.toString() : void 0)) {
	          return el.val(value != null ? value : '');
	        }
	      } else {
	        if (el.type === 'select-multiple') {
	          if (value != null) {
	            _results = [];
	            for (_i = 0, _len = el.length; _i < _len; _i++) {
	              o = el[_i];
	              _results.push(o.selected = (_ref2 = o.value, __indexOf.call(value, _ref2) >= 0));
	            }
	            return _results;
	          }
	        } else if ((value != null ? value.toString() : void 0) !== ((_ref3 = el.value) != null ? _ref3.toString() : void 0)) {
	          return el.value = value != null ? value : '';
	        }
	      }
	    }
	  };

	  Rivets["public"].binders["if"] = {
	    block: true,
	    priority: 4000,
	    bind: function(el) {
	      var attr, declaration;
	      if (this.marker == null) {
	        attr = [this.view.prefix, this.type].join('-').replace('--', '-');
	        declaration = el.getAttribute(attr);
	        this.marker = document.createComment(" rivets: " + this.type + " " + declaration + " ");
	        this.bound = false;
	        el.removeAttribute(attr);
	        el.parentNode.insertBefore(this.marker, el);
	        return el.parentNode.removeChild(el);
	      }
	    },
	    unbind: function() {
	      var _ref1;
	      return (_ref1 = this.nested) != null ? _ref1.unbind() : void 0;
	    },
	    routine: function(el, value) {
	      var key, model, models, _ref1;
	      if (!!value === !this.bound) {
	        if (value) {
	          models = {};
	          _ref1 = this.view.models;
	          for (key in _ref1) {
	            model = _ref1[key];
	            models[key] = model;
	          }
	          (this.nested || (this.nested = new Rivets.View(el, models, this.view.options()))).bind();
	          this.marker.parentNode.insertBefore(el, this.marker.nextSibling);
	          return this.bound = true;
	        } else {
	          el.parentNode.removeChild(el);
	          this.nested.unbind();
	          return this.bound = false;
	        }
	      }
	    },
	    update: function(models) {
	      var _ref1;
	      return (_ref1 = this.nested) != null ? _ref1.update(models) : void 0;
	    }
	  };

	  Rivets["public"].binders.unless = {
	    block: true,
	    priority: 4000,
	    bind: function(el) {
	      return Rivets["public"].binders["if"].bind.call(this, el);
	    },
	    unbind: function() {
	      return Rivets["public"].binders["if"].unbind.call(this);
	    },
	    routine: function(el, value) {
	      return Rivets["public"].binders["if"].routine.call(this, el, !value);
	    },
	    update: function(models) {
	      return Rivets["public"].binders["if"].update.call(this, models);
	    }
	  };

	  Rivets["public"].binders['on-*'] = {
	    "function": true,
	    priority: 1000,
	    unbind: function(el) {
	      if (this.handler) {
	        return Rivets.Util.unbindEvent(el, this.args[0], this.handler);
	      }
	    },
	    routine: function(el, value) {
	      if (this.handler) {
	        Rivets.Util.unbindEvent(el, this.args[0], this.handler);
	      }
	      return Rivets.Util.bindEvent(el, this.args[0], this.handler = this.eventHandler(value));
	    }
	  };

	  Rivets["public"].binders['each-*'] = {
	    block: true,
	    priority: 4000,
	    bind: function(el) {
	      var attr, view, _i, _len, _ref1;
	      if (this.marker == null) {
	        attr = [this.view.prefix, this.type].join('-').replace('--', '-');
	        this.marker = document.createComment(" rivets: " + this.type + " ");
	        this.iterated = [];
	        el.removeAttribute(attr);
	        el.parentNode.insertBefore(this.marker, el);
	        el.parentNode.removeChild(el);
	      } else {
	        _ref1 = this.iterated;
	        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	          view = _ref1[_i];
	          view.bind();
	        }
	      }
	    },
	    unbind: function(el) {
	      var view, _i, _len, _ref1, _results;
	      if (this.iterated != null) {
	        _ref1 = this.iterated;
	        _results = [];
	        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	          view = _ref1[_i];
	          _results.push(view.unbind());
	        }
	        return _results;
	      }
	    },
	    routine: function(el, collection) {
	      var binding, data, i, index, key, model, modelName, options, previous, template, view, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;
	      modelName = this.args[0];
	      collection = collection || [];
	      if (this.iterated.length > collection.length) {
	        _ref1 = Array(this.iterated.length - collection.length);
	        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	          i = _ref1[_i];
	          view = this.iterated.pop();
	          view.unbind();
	          this.marker.parentNode.removeChild(view.els[0]);
	        }
	      }
	      for (index = _j = 0, _len1 = collection.length; _j < _len1; index = ++_j) {
	        model = collection[index];
	        data = {
	          index: index
	        };
	        data[modelName] = model;
	        if (this.iterated[index] == null) {
	          _ref2 = this.view.models;
	          for (key in _ref2) {
	            model = _ref2[key];
	            if (data[key] == null) {
	              data[key] = model;
	            }
	          }
	          previous = this.iterated.length ? this.iterated[this.iterated.length - 1].els[0] : this.marker;
	          options = this.view.options();
	          options.preloadData = true;
	          template = el.cloneNode(true);
	          view = new Rivets.View(template, data, options);
	          view.bind();
	          this.iterated.push(view);
	          this.marker.parentNode.insertBefore(template, previous.nextSibling);
	        } else if (this.iterated[index].models[modelName] !== model) {
	          this.iterated[index].update(data);
	        }
	      }
	      if (el.nodeName === 'OPTION') {
	        _ref3 = this.view.bindings;
	        _results = [];
	        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
	          binding = _ref3[_k];
	          if (binding.el === this.marker.parentNode && binding.type === 'value') {
	            _results.push(binding.sync());
	          } else {
	            _results.push(void 0);
	          }
	        }
	        return _results;
	      }
	    },
	    update: function(models) {
	      var data, key, model, view, _i, _len, _ref1, _results;
	      data = {};
	      for (key in models) {
	        model = models[key];
	        if (key !== this.args[0]) {
	          data[key] = model;
	        }
	      }
	      _ref1 = this.iterated;
	      _results = [];
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        view = _ref1[_i];
	        _results.push(view.update(data));
	      }
	      return _results;
	    }
	  };

	  Rivets["public"].binders['class-*'] = function(el, value) {
	    var elClass;
	    elClass = " " + el.className + " ";
	    if (!value === (elClass.indexOf(" " + this.args[0] + " ") !== -1)) {
	      return el.className = value ? "" + el.className + " " + this.args[0] : elClass.replace(" " + this.args[0] + " ", ' ').trim();
	    }
	  };

	  Rivets["public"].binders['*'] = function(el, value) {
	    if (value != null) {
	      return el.setAttribute(this.type, value);
	    } else {
	      return el.removeAttribute(this.type);
	    }
	  };

	  Rivets["public"].adapters['.'] = {
	    id: '_rv',
	    counter: 0,
	    weakmap: {},
	    weakReference: function(obj) {
	      var id, _base, _name;
	      if (!obj.hasOwnProperty(this.id)) {
	        id = this.counter++;
	        Object.defineProperty(obj, this.id, {
	          value: id
	        });
	      }
	      return (_base = this.weakmap)[_name = obj[this.id]] || (_base[_name] = {
	        callbacks: {}
	      });
	    },
	    cleanupWeakReference: function(ref, id) {
	      if (!Object.keys(ref.callbacks).length) {
	        if (!(ref.pointers && Object.keys(ref.pointers).length)) {
	          return delete this.weakmap[id];
	        }
	      }
	    },
	    stubFunction: function(obj, fn) {
	      var map, original, weakmap;
	      original = obj[fn];
	      map = this.weakReference(obj);
	      weakmap = this.weakmap;
	      return obj[fn] = function() {
	        var callback, k, r, response, _i, _len, _ref1, _ref2, _ref3, _ref4;
	        response = original.apply(obj, arguments);
	        _ref1 = map.pointers;
	        for (r in _ref1) {
	          k = _ref1[r];
	          _ref4 = (_ref2 = (_ref3 = weakmap[r]) != null ? _ref3.callbacks[k] : void 0) != null ? _ref2 : [];
	          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
	            callback = _ref4[_i];
	            callback();
	          }
	        }
	        return response;
	      };
	    },
	    observeMutations: function(obj, ref, keypath) {
	      var fn, functions, map, _base, _i, _len;
	      if (Array.isArray(obj)) {
	        map = this.weakReference(obj);
	        if (map.pointers == null) {
	          map.pointers = {};
	          functions = ['push', 'pop', 'shift', 'unshift', 'sort', 'reverse', 'splice'];
	          for (_i = 0, _len = functions.length; _i < _len; _i++) {
	            fn = functions[_i];
	            this.stubFunction(obj, fn);
	          }
	        }
	        if ((_base = map.pointers)[ref] == null) {
	          _base[ref] = [];
	        }
	        if (__indexOf.call(map.pointers[ref], keypath) < 0) {
	          return map.pointers[ref].push(keypath);
	        }
	      }
	    },
	    unobserveMutations: function(obj, ref, keypath) {
	      var idx, map, pointers;
	      if (Array.isArray(obj) && (obj[this.id] != null)) {
	        if (map = this.weakmap[obj[this.id]]) {
	          if (pointers = map.pointers[ref]) {
	            if ((idx = pointers.indexOf(keypath)) >= 0) {
	              pointers.splice(idx, 1);
	            }
	            if (!pointers.length) {
	              delete map.pointers[ref];
	            }
	            return this.cleanupWeakReference(map, obj[this.id]);
	          }
	        }
	      }
	    },
	    observe: function(obj, keypath, callback) {
	      var callbacks, desc, value;
	      callbacks = this.weakReference(obj).callbacks;
	      if (callbacks[keypath] == null) {
	        callbacks[keypath] = [];
	        desc = Object.getOwnPropertyDescriptor(obj, keypath);
	        if (!((desc != null ? desc.get : void 0) || (desc != null ? desc.set : void 0))) {
	          value = obj[keypath];
	          Object.defineProperty(obj, keypath, {
	            enumerable: true,
	            get: function() {
	              return value;
	            },
	            set: (function(_this) {
	              return function(newValue) {
	                var map, _i, _len, _ref1;
	                if (newValue !== value) {
	                  _this.unobserveMutations(value, obj[_this.id], keypath);
	                  value = newValue;
	                  if (map = _this.weakmap[obj[_this.id]]) {
	                    callbacks = map.callbacks;
	                    if (callbacks[keypath]) {
	                      _ref1 = callbacks[keypath].slice();
	                      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	                        callback = _ref1[_i];
	                        if (__indexOf.call(callbacks[keypath], callback) >= 0) {
	                          callback();
	                        }
	                      }
	                    }
	                    return _this.observeMutations(newValue, obj[_this.id], keypath);
	                  }
	                }
	              };
	            })(this)
	          });
	        }
	      }
	      if (__indexOf.call(callbacks[keypath], callback) < 0) {
	        callbacks[keypath].push(callback);
	      }
	      return this.observeMutations(obj[keypath], obj[this.id], keypath);
	    },
	    unobserve: function(obj, keypath, callback) {
	      var callbacks, idx, map;
	      if (map = this.weakmap[obj[this.id]]) {
	        if (callbacks = map.callbacks[keypath]) {
	          if ((idx = callbacks.indexOf(callback)) >= 0) {
	            callbacks.splice(idx, 1);
	            if (!callbacks.length) {
	              delete map.callbacks[keypath];
	            }
	          }
	          this.unobserveMutations(obj[keypath], obj[this.id], keypath);
	          return this.cleanupWeakReference(map, obj[this.id]);
	        }
	      }
	    },
	    get: function(obj, keypath) {
	      return obj[keypath];
	    },
	    set: function(obj, keypath, value) {
	      return obj[keypath] = value;
	    }
	  };

	  Rivets.factory = function(sightglass) {
	    Rivets.sightglass = sightglass;
	    Rivets["public"]._ = Rivets;
	    return Rivets["public"];
	  };

	  if (typeof (typeof module !== "undefined" && module !== null ? module.exports : void 0) === 'object') {
	    module.exports = Rivets.factory(__webpack_require__(8));
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function(sightglass) {
	      return this.rivets = Rivets.factory(sightglass);
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    this.rivets = Rivets.factory(sightglass);
	  }

	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)(module)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {
	  // Public sightglass interface.
	  function sightglass(obj, keypath, callback, options) {
	    return new Observer(obj, keypath, callback, options)
	  }

	  // Batteries not included.
	  sightglass.adapters = {}

	  // Constructs a new keypath observer and kicks things off.
	  function Observer(obj, keypath, callback, options) {
	    this.options = options || {}
	    this.options.adapters = this.options.adapters || {}
	    this.obj = obj
	    this.keypath = keypath
	    this.callback = callback
	    this.objectPath = []
	    this.parse()

	    if (isObject(this.target = this.realize())) {
	      this.set(true, this.key, this.target, this.callback)
	    }
	  }

	  // Tokenizes the provided keypath string into interface + path tokens for the
	  // observer to work with.
	  Observer.tokenize = function(keypath, interfaces, root) {
	    var tokens = []
	    var current = {i: root, path: ''}
	    var index, chr

	    for (index = 0; index < keypath.length; index++) {
	      chr = keypath.charAt(index)

	      if (!!~interfaces.indexOf(chr)) {
	        tokens.push(current)
	        current = {i: chr, path: ''}
	      } else {
	        current.path += chr
	      }
	    }

	    tokens.push(current)
	    return tokens
	  }

	  // Parses the keypath using the interfaces defined on the view. Sets variables
	  // for the tokenized keypath as well as the end key.
	  Observer.prototype.parse = function() {
	    var interfaces = this.interfaces()
	    var root, path

	    if (!interfaces.length) {
	      error('Must define at least one adapter interface.')
	    }

	    if (!!~interfaces.indexOf(this.keypath[0])) {
	      root = this.keypath[0]
	      path = this.keypath.substr(1)
	    } else {
	      if (typeof (root = this.options.root || sightglass.root) === 'undefined') {
	        error('Must define a default root adapter.')
	      }

	      path = this.keypath
	    }

	    this.tokens = Observer.tokenize(path, interfaces, root)
	    this.key = this.tokens.pop()
	  }

	  // Realizes the full keypath, attaching observers for every key and correcting
	  // old observers to any changed objects in the keypath.
	  Observer.prototype.realize = function() {
	    var current = this.obj
	    var unreached = false
	    var prev

	    this.tokens.forEach(function(token, index) {
	      if (isObject(current)) {
	        if (typeof this.objectPath[index] !== 'undefined') {
	          if (current !== (prev = this.objectPath[index])) {
	            this.set(false, token, prev, this.update.bind(this))
	            this.set(true, token, current, this.update.bind(this))
	            this.objectPath[index] = current
	          }
	        } else {
	          this.set(true, token, current, this.update.bind(this))
	          this.objectPath[index] = current
	        }

	        current = this.get(token, current)
	      } else {
	        if (unreached === false) {
	          unreached = index
	        }

	        if (prev = this.objectPath[index]) {
	          this.set(false, token, prev, this.update.bind(this))
	        }
	      }
	    }, this)

	    if (unreached !== false) {
	      this.objectPath.splice(unreached)
	    }

	    return current
	  }

	  // Updates the keypath. This is called when any intermediary key is changed.
	  Observer.prototype.update = function() {
	    var next, oldValue

	    if ((next = this.realize()) !== this.target) {
	      if (isObject(this.target)) {
	        this.set(false, this.key, this.target, this.callback)
	      }

	      if (isObject(next)) {
	        this.set(true, this.key, next, this.callback)
	      }

	      oldValue = this.value()
	      this.target = next

	      if (this.value() !== oldValue) this.callback()
	    }
	  }

	  // Reads the current end value of the observed keypath. Returns undefined if
	  // the full keypath is unreachable.
	  Observer.prototype.value = function() {
	    if (isObject(this.target)) {
	      return this.get(this.key, this.target)
	    }
	  }

	  // Sets the current end value of the observed keypath. Calling setValue when
	  // the full keypath is unreachable is a no-op.
	  Observer.prototype.setValue = function(value) {
	    if (isObject(this.target)) {
	      this.adapter(this.key).set(this.target, this.key.path, value)
	    }
	  }

	  // Gets the provided key on an object.
	  Observer.prototype.get = function(key, obj) {
	    return this.adapter(key).get(obj, key.path)
	  }

	  // Observes or unobserves a callback on the object using the provided key.
	  Observer.prototype.set = function(active, key, obj, callback) {
	    var action = active ? 'observe' : 'unobserve'
	    this.adapter(key)[action](obj, key.path, callback)
	  }

	  // Returns an array of all unique adapter interfaces available.
	  Observer.prototype.interfaces = function() {
	    var interfaces = Object.keys(this.options.adapters)

	    Object.keys(sightglass.adapters).forEach(function(i) {
	      if (!~interfaces.indexOf(i)) {
	        interfaces.push(i)
	      }
	    })

	    return interfaces
	  }

	  // Convenience function to grab the adapter for a specific key.
	  Observer.prototype.adapter = function(key) {
	    return this.options.adapters[key.i] ||
	      sightglass.adapters[key.i]
	  }

	  // Unobserves the entire keypath.
	  Observer.prototype.unobserve = function() {
	    var obj

	    this.tokens.forEach(function(token, index) {
	      if (obj = this.objectPath[index]) {
	        this.set(false, token, obj, this.update.bind(this))
	      }
	    }, this)

	    if (isObject(this.target)) {
	      this.set(false, this.key, this.target, this.callback)
	    }
	  }

	  // Check if a value is an object than can be observed.
	  function isObject(obj) {
	    return typeof obj === 'object' && obj !== null
	  }

	  // Error thrower.
	  function error(message) {
	    throw new Error('[sightglass] ' + message)
	  }

	  // Export module for Node and the browser.
	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = sightglass
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return this.sightglass = sightglass
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	  } else {
	    this.sightglass = sightglass
	  }
	}).call(this);


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	//
	//  ____  _                           _
	// / ___|| |_ __ _ _ __   ___  ___   (_)___  (*)
	// \___ \| __/ _` | '_ \ / _ \/ __|  | / __|
	//  ___) | || (_| | |_) |  __/\__ \_ | \__ \
	// |____/ \__\__,_| .__/ \___||___(_)/ |___/
	//              |_|              |__/
	//
	// (*) the Javascript MVC microframework that does just enough
	//
	// (c) Hay Kranen < hay@bykr.org >
	// Released under the terms of the MIT license
	// < http://en.wikipedia.org/wiki/MIT_License >
	//
	// Stapes.js : http://hay.github.com/stapes
	;(function() {
	    'use strict';

	    var VERSION = "0.8.1";

	    // Global counter for all events in all modules (including mixed in objects)
	    var guid = 1;

	    // Makes _.create() faster
	    if (!Object.create) {
	        var CachedFunction = function(){};
	    }

	    // So we can use slice.call for arguments later on
	    var slice = Array.prototype.slice;

	    // Private attributes and helper functions, stored in an object so they
	    // are overwritable by plugins
	    var _ = {
	        // Properties
	        attributes : {},

	        eventHandlers : {
	            "-1" : {} // '-1' is used for the global event handling
	        },

	        guid : -1,

	        // Methods
	        addEvent : function(event) {
	            // If we don't have any handlers for this type of event, add a new
	            // array we can use to push new handlers
	            if (!_.eventHandlers[event.guid][event.type]) {
	                _.eventHandlers[event.guid][event.type] = [];
	            }

	            // Push an event object
	            _.eventHandlers[event.guid][event.type].push({
	                "guid" : event.guid,
	                "handler" : event.handler,
	                "scope" : event.scope,
	                "type" : event.type
	            });
	        },

	        addEventHandler : function(argTypeOrMap, argHandlerOrScope, argScope) {
	            var eventMap = {},
	                scope;

	            if (typeof argTypeOrMap === "string") {
	                scope = argScope || false;
	                eventMap[ argTypeOrMap ] = argHandlerOrScope;
	            } else {
	                scope = argHandlerOrScope || false;
	                eventMap = argTypeOrMap;
	            }

	            for (var eventString in eventMap) {
	                var handler = eventMap[eventString];
	                var events = eventString.split(" ");

	                for (var i = 0, l = events.length; i < l; i++) {
	                    var eventType = events[i];
	                    _.addEvent.call(this, {
	                        "guid" : this._guid || this._.guid,
	                        "handler" : handler,
	                        "scope" : scope,
	                        "type" : eventType
	                    });
	                }
	            }
	        },

	        addGuid : function(object, forceGuid) {
	            if (object._guid && !forceGuid) return;

	            object._guid = guid++;

	            _.attributes[object._guid] = {};
	            _.eventHandlers[object._guid] = {};
	        },

	        // This is a really small utility function to save typing and produce
	        // better optimized code
	        attr : function(guid) {
	            return _.attributes[guid];
	        },

	        clone : function(obj) {
	            var type = _.typeOf(obj);

	            if (type === 'object') {
	                return _.extend({}, obj);
	            }

	            if (type === 'array') {
	                return obj.slice(0);
	            }
	        },

	        create : function(proto) {
	            if (Object.create) {
	                return Object.create(proto);
	            } else {
	                CachedFunction.prototype = proto;
	                return new CachedFunction();
	            }
	        },

	        createSubclass : function(props, includeEvents) {
	            props = props || {};
	            includeEvents = includeEvents || false;

	            var superclass = props.superclass.prototype;

	            // Objects always have a constructor, so we need to be sure this is
	            // a property instead of something from the prototype
	            var realConstructor = props.hasOwnProperty('constructor') ? props.constructor : function(){};

	            function constructor() {
	                // Be kind to people forgetting new
	                if (!(this instanceof constructor)) {
	                    throw new Error("Please use 'new' when initializing Stapes classes");
	                }

	                // If this class has events add a GUID as well
	                if (this.on) {
	                    _.addGuid( this, true );
	                }

	                realConstructor.apply(this, arguments);
	            }

	            if (includeEvents) {
	                _.extend(superclass, Events);
	            }

	            constructor.prototype = _.create(superclass);
	            constructor.prototype.constructor = constructor;

	            _.extend(constructor, {
	                extend : function() {
	                    return _.extendThis.apply(this, arguments);
	                },

	                // We can't call this 'super' because that's a reserved keyword
	                // and fails in IE8
	                'parent' : superclass,

	                proto : function() {
	                    return _.extendThis.apply(this.prototype, arguments);
	                },

	                subclass : function(obj) {
	                    obj = obj || {};
	                    obj.superclass = this;
	                    return _.createSubclass(obj);
	                }
	            });

	            // Copy all props given in the definition to the prototype
	            for (var key in props) {
	                if (key !== 'constructor' && key !== 'superclass') {
	                    constructor.prototype[key] = props[key];
	                }
	            }

	            return constructor;
	        },

	        emitEvents : function(type, data, explicitType, explicitGuid) {
	            explicitType = explicitType || false;
	            explicitGuid = explicitGuid || this._guid;

	            // #30: make a local copy of handlers to prevent problems with
	            // unbinding the event while unwinding the loop
	            var handlers = slice.call(_.eventHandlers[explicitGuid][type]);

	            for (var i = 0, l = handlers.length; i < l; i++) {
	                // Clone the event to prevent issue #19
	                var event = _.extend({}, handlers[i]);
	                var scope = (event.scope) ? event.scope : this;

	                if (explicitType) {
	                    event.type = explicitType;
	                }

	                event.scope = scope;
	                event.handler.call(event.scope, data, event);
	            }
	        },

	        // Extend an object with more objects
	        extend : function() {
	            var args = slice.call(arguments);
	            var object = args.shift();

	            for (var i = 0, l = args.length; i < l; i++) {
	                var props = args[i];
	                for (var key in props) {
	                    object[key] = props[key];
	                }
	            }

	            return object;
	        },

	        // The same as extend, but uses the this value as the scope
	        extendThis : function() {
	            var args = slice.call(arguments);
	            args.unshift(this);
	            return _.extend.apply(this, args);
	        },

	        // from http://stackoverflow.com/a/2117523/152809
	        makeUuid : function() {
	            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	                var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
	                return v.toString(16);
	            });
	        },

	        removeAttribute : function(keys, silent) {
	            silent = silent || false;

	            // Split the key, maybe we want to remove more than one item
	            var attributes = _.trim(keys).split(" ")
	                ,mutateData = {}
	                ;

	            // Actually delete the item
	            for (var i = 0, l = attributes.length; i < l; i++) {
	                var key = _.trim(attributes[i]);

	                if (key) {
	                    // Store data for mutate event
	                    mutateData.key = key;
	                    mutateData.oldValue = _.attr(this._guid)[key];

	                    delete _.attr(this._guid)[key];

	                    // If 'silent' is set, do not throw any events
	                    if (!silent) {
	                        this.emit('change', key);
	                        this.emit('change:' + key);
	                        this.emit('mutate', mutateData);
	                        this.emit('mutate:' + key, mutateData);
	                        this.emit('remove', key);
	                        this.emit('remove:' + key);
	                    }

	                    // clean up
	                    delete mutateData.oldValue;
	                }
	            }
	        },

	        removeEventHandler : function(type, handler) {
	            var handlers = _.eventHandlers[this._guid];

	            if (type && handler) {
	                // Remove a specific handler
	                handlers = handlers[type];
	                if (!handlers) return;

	                for (var i = 0, l = handlers.length, h; i < l; i++) {
	                    h = handlers[i].handler;
	                    if (h && h === handler) {
	                        handlers.splice(i--, 1);
	                        l--;
	                    }
	                }
	            } else if (type) {
	                // Remove all handlers for a specific type
	                delete handlers[type];
	            } else {
	                // Remove all handlers for this module
	                _.eventHandlers[this._guid] = {};
	            }
	        },

	        setAttribute : function(key, value, silent) {
	            silent = silent || false;

	            // We need to do this before we actually add the item :)
	            var itemExists = this.has(key);
	            var oldValue = _.attr(this._guid)[key];

	            // Is the value different than the oldValue? If not, ignore this call
	            if (value === oldValue) {
	                return;
	            }

	            // Actually add the item to the attributes
	            _.attr(this._guid)[key] = value;

	            // If 'silent' flag is set, do not throw any events
	            if (silent) {
	                return;
	            }

	            // Throw a generic event
	            this.emit('change', key);

	            // And a namespaced event as well, NOTE that we pass value instead of
	            // key here!
	            this.emit('change:' + key, value);

	            // Throw namespaced and non-namespaced 'mutate' events as well with
	            // the old value data as well and some extra metadata such as the key
	            var mutateData = {
	                "key" : key,
	                "newValue" : value,
	                "oldValue" : oldValue || null
	            };

	            this.emit('mutate', mutateData);
	            this.emit('mutate:' + key, mutateData);

	            // Also throw a specific event for this type of set
	            var specificEvent = itemExists ? 'update' : 'create';

	            this.emit(specificEvent, key);

	            // And a namespaced event as well, NOTE that we pass value instead of key
	            this.emit(specificEvent + ':' + key, value);
	        },

	        trim : function(str) {
	            return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	        },

	        typeOf : function(val) {
	            if (val === null || typeof val === "undefined") {
	                // This is a special exception for IE, in other browsers the
	                // method below works all the time
	                return String(val);
	            } else {
	                return Object.prototype.toString.call(val).replace(/\[object |\]/g, '').toLowerCase();
	            }
	        },

	        updateAttribute : function(key, fn, silent) {
	            var item = this.get(key);

	            // In previous versions of Stapes we didn't have the check for object,
	            // but still this worked. In 0.7.0 it suddenly doesn't work anymore and
	            // we need the check. Why? I have no clue.
	            var type = _.typeOf(item);

	            if (type === 'object' || type === 'array') {
	                item = _.clone(item);
	            }

	            var newValue = fn.call(this, item, key);
	            _.setAttribute.call(this, key, newValue, silent || false);
	        }
	    };

	    // Can be mixed in later using Stapes.mixinEvents(object);
	    var Events = {
	        emit : function(types, data) {
	            data = (typeof data === "undefined") ? null : data;

	            var splittedTypes = types.split(" ");

	            for (var i = 0, l = splittedTypes.length; i < l; i++) {
	                var type = splittedTypes[i];

	                // First 'all' type events: is there an 'all' handler in the
	                // global stack?
	                if (_.eventHandlers[-1].all) {
	                    _.emitEvents.call(this, "all", data, type, -1);
	                }

	                // Catch all events for this type?
	                if (_.eventHandlers[-1][type]) {
	                    _.emitEvents.call(this, type, data, type, -1);
	                }

	                if (typeof this._guid === 'number') {
	                    // 'all' event for this specific module?
	                    if (_.eventHandlers[this._guid].all) {
	                        _.emitEvents.call(this, "all", data, type);
	                    }

	                    // Finally, normal events :)
	                    if (_.eventHandlers[this._guid][type]) {
	                        _.emitEvents.call(this, type, data);
	                    }
	                }
	            }
	        },

	        off : function() {
	            _.removeEventHandler.apply(this, arguments);
	        },

	        on : function() {
	            _.addEventHandler.apply(this, arguments);
	        }
	    };

	    _.Module = function() {

	    };

	    _.Module.prototype = {
	        each : function(fn, ctx) {
	            var attr = _.attr(this._guid);
	            for (var key in attr) {
	                var value = attr[key];
	                fn.call(ctx || this, value, key);
	            }
	        },

	        extend : function() {
	            return _.extendThis.apply(this, arguments);
	        },

	        filter : function(fn) {
	            var filtered = [];
	            var attributes = _.attr(this._guid);

	            for (var key in attributes) {
	                if ( fn.call(this, attributes[key], key)) {
	                    filtered.push( attributes[key] );
	                }
	            }

	            return filtered;
	        },

	        get : function(input) {
	            if (typeof input === "string") {
	                // If there is more than one argument, give back an object,
	                // like Underscore's pick()
	                if (arguments.length > 1) {
	                    var results = {};

	                    for (var i = 0, l = arguments.length; i < l; i++) {
	                        var key = arguments[i];
	                        results[key] = this.get(key);
	                    }

	                    return results;
	                } else {
	                    return this.has(input) ? _.attr(this._guid)[input] : null;
	                }
	            } else if (typeof input === "function") {
	                var items = this.filter(input);
	                return (items.length) ? items[0] : null;
	            }
	        },

	        getAll : function() {
	            return _.clone( _.attr(this._guid) );
	        },

	        getAllAsArray : function() {
	            var arr = [];
	            var attributes = _.attr(this._guid);

	            for (var key in attributes) {
	                var value = attributes[key];

	                if (_.typeOf(value) === "object" && !value.id) {
	                    value.id = key;
	                }

	                arr.push(value);
	            }

	            return arr;
	        },

	        has : function(key) {
	            return (typeof _.attr(this._guid)[key] !== "undefined");
	        },

	        map : function(fn, ctx) {
	            var mapped = [];
	            this.each(function(value, key) {
	                mapped.push( fn.call(ctx || this, value, key) );
	            }, ctx || this);
	            return mapped;
	        },

	        // Akin to set(), but makes a unique id
	        push : function(input, silent) {
	            if (_.typeOf(input) === "array") {
	                for (var i = 0, l = input.length; i < l; i++) {
	                    _.setAttribute.call(this, _.makeUuid(), input[i], silent || false);
	                }
	            } else {
	                _.setAttribute.call(this, _.makeUuid(), input, silent || false);
	            }

	            return this;
	        },

	        remove : function(input, silent) {
	            if (typeof input === 'undefined') {
	                // With no arguments, remove deletes all attributes
	                _.attributes[this._guid] = {};
	                this.emit('change remove');
	            } else if (typeof input === "function") {
	                this.each(function(item, key) {
	                    if (input(item)) {
	                        _.removeAttribute.call(this, key, silent);
	                    }
	                });
	            } else {
	                // nb: checking for exists happens in removeAttribute
	                _.removeAttribute.call(this, input, silent || false);
	            }

	            return this;
	        },

	        set : function(objOrKey, valueOrSilent, silent) {
	            if (typeof objOrKey === "object") {
	                for (var key in objOrKey) {
	                    _.setAttribute.call(this, key, objOrKey[key], valueOrSilent || false);
	                }
	            } else {
	                _.setAttribute.call(this, objOrKey, valueOrSilent, silent || false);
	            }

	            return this;
	        },

	        size : function() {
	            var size = 0;
	            var attr = _.attr(this._guid);

	            for (var key in attr) {
	                size++;
	            }

	            return size;
	        },

	        update : function(keyOrFn, fn, silent) {
	            if (typeof keyOrFn === "string") {
	                _.updateAttribute.call(this, keyOrFn, fn, silent || false);
	            } else if (typeof keyOrFn === "function") {
	                this.each(function(value, key) {
	                    _.updateAttribute.call(this, key, keyOrFn);
	                });
	            }

	            return this;
	        }
	    };

	    var Stapes = {
	        "_" : _, // private helper functions and properties

	        "extend" : function() {
	            return _.extendThis.apply(_.Module.prototype, arguments);
	        },

	        "mixinEvents" : function(obj) {
	            obj = obj || {};

	            _.addGuid(obj);

	            return _.extend(obj, Events);
	        },

	        "on" : function() {
	            _.addEventHandler.apply(this, arguments);
	        },

	        "subclass" : function(obj, classOnly) {
	            classOnly = classOnly || false;
	            obj = obj || {};
	            obj.superclass = classOnly ? function(){} : _.Module;
	            return _.createSubclass(obj, !classOnly);
	        },

	        "version" : VERSION
	    };

	    // This library can be used as an AMD module, a Node.js module, or an
	    // old fashioned global
	    if (true) {
	        // Server
	        if (typeof module !== "undefined" && module.exports) {
	            exports = module.exports = Stapes;
	        }
	        exports.Stapes = Stapes;
	    } else if (typeof define === "function" && define.amd) {
	        // AMD
	        define('stapes', function() {
	            return Stapes;
	        });
	    } else {
	        // Global scope
	        window.Stapes = Stapes;
	    }
	})();


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * View
	 * @module mcore/view
	 * @author vfasky <vfasky@gmail.com>
	 */
	"use strict";
	var $, $body, $win, Stapes, Template, _isIOS, _isWeixinBrowser, exports, util;

	$ = __webpack_require__(4);

	Template = __webpack_require__(5);

	Stapes = __webpack_require__(9);

	util = __webpack_require__(1);

	$win = $(window);

	$body = $('body');

	_isWeixinBrowser = /MicroMessenger/i.test(window.navigator.userAgent);

	_isIOS = /iphone|ipad/gi.test(window.navigator.appVersion);

	exports = module.exports = Stapes.subclass({
	  constructor: function($el, app) {
	    this.$el = $el;
	    this.app = app;
	    this.$win = $win;
	    this.$body = $body;
	    this.util = util;
	    this._cacheMap = {};
	    this.isWeixinBrowser = _isWeixinBrowser;
	    this.isIOS = _isIOS;
	    this.tpl = false;
	    this.beforeInit();
	    this.init();
	    return this.watch();
	  },
	  clone: function(value) {
	    return util.clone(value);
	  },
	  asyncSet: function(key, promise) {
	    return promise.then((function(_this) {
	      return function(val) {
	        _this.set(key, val);
	        return val;
	      };
	    })(this));
	  },
	  setTitle: function(title) {
	    var $iframe;
	    this.title = title;
	    if (document.title === this.title) {
	      return;
	    }
	    document.title = this.title;
	    if (this.isWeixinBrowser && this.isIOS) {
	      $iframe = $('<iframe src="/favicon.ico"></iframe>');
	      return $iframe.one('load', function() {
	        return setTimeout(function() {
	          return $iframe.remove();
	        }, 0);
	      }).appendTo(this.$body);
	    }
	  },
	  render: function(uri, data) {
	    if (data == null) {
	      data = {};
	    }
	    return Template.render(uri, data, this);
	  },
	  renderString: function(html, data) {
	    if (data == null) {
	      data = {};
	    }
	    return Template.renderString(html, data, this);
	  },
	  bind: function(data) {
	    if (data == null) {
	      data = {};
	    }
	    return Template.bind(data, this);
	  },
	  when: function() {
	    return $.when.apply(this, arguments);
	  },
	  destroy: function() {
	    if (this.tpl) {
	      this.tpl.destroy();
	    }
	    return this.$el.remove();
	  },

	  /**
	   * 缓存，基本内存，刷新页面失效
	   * @author vfasky <vfasky@gmail.com>
	   *
	   */
	  memoryCache: function(key) {
	    var cache, proxy;
	    proxy = util.promiseCacheMemoryproxy;
	    cache = {
	      has: function(promise) {
	        return util.promiseCache(key, promise, {
	          proxy: proxy
	        });
	      },
	      remove: function() {
	        return proxy.remove(key);
	      }
	    };
	    return cache;
	  },

	  /**
	   * 缓存，基本 localStorage
	   * @author vfasky <vfasky@gmail.com>
	   *
	   */
	  localCache: function(key) {
	    var cache, proxy;
	    proxy = util.promiseCacheLocalProxy;
	    cache = {
	      has: function(promise, time) {
	        if (time == null) {
	          time = Infinity;
	        }
	        return util.promiseCache(key, promise, {
	          proxy: proxy,
	          time: time
	        });
	      },
	      remove: function() {
	        return proxy.remove(key);
	      }
	    };
	    return cache;
	  },

	  /**
	   * 缓存，基本当前 view 的生命周期
	   * @author vfasky <vfasky@gmail.com>
	   *
	   */
	  sessionCach: function(key) {
	    var cache, proxy;
	    proxy = this.promiseCacheSessionProxy();
	    cache = {
	      has: function(promise) {
	        return util.promiseCache(key, promise, {
	          proxy: proxy
	        });
	      },
	      remove: function() {
	        return proxy.remove(key);
	      }
	    };
	    return cache;
	  },
	  promiseCacheSessionProxy: function() {
	    var proxy;
	    proxy = {
	      set: (function(_this) {
	        return function(key, value) {
	          return _this._cacheMap[key] = value;
	        };
	      })(this),
	      get: (function(_this) {
	        return function(key) {
	          return _this._cacheMap[key] || null;
	        };
	      })(this)
	    };
	    return proxy;
	  },
	  back: function() {
	    if (window.history.length > 1) {
	      window.history.back();
	    } else {
	      window.location.href = '#';
	    }
	    return false;
	  },
	  beforeInit: function() {},
	  init: function() {},
	  run: function() {},
	  afterRun: function() {},
	  watch: function() {}
	});


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * ui
	 * @module mcore/ui
	 * @author vfasky <vfasky@gmail.com>
	 */
	"use strict";
	var $, $body, Stapes, Template, exports;

	$ = __webpack_require__(4);

	Template = __webpack_require__(5);

	Stapes = __webpack_require__(9);

	$body = $('body');

	exports = module.exports = Stapes.subclass({
	  constructor: function($el, options) {
	    this.options = options != null ? options : {};
	    this.$el = $('<div/>');
	    this.$parent = $el || $body;
	    this.on('render', (function(_this) {
	      return function() {
	        return _this.$el.appendTo(_this.$parent);
	      };
	    })(this));
	    this.init();
	    return this.watch();
	  },
	  destroy: function() {
	    if (this.tpl) {
	      this.tpl.destroy();
	    }
	    return this.$el.remove();
	  },
	  render: function(uri, data) {
	    if (data == null) {
	      data = {};
	    }
	    return Template.render(uri, data, this);
	  },
	  renderString: function(html, data) {
	    if (data == null) {
	      data = {};
	    }
	    return Template.renderString(html, data, this);
	  },
	  init: function() {},
	  watch: function() {}
	});


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * app
	 * @module mcore/app
	 * @author vfasky <vfasky@gmail.com>
	 */
	"use strict";
	var $, Stapes, config, exports, route, util;

	$ = __webpack_require__(4);

	Stapes = __webpack_require__(9);

	route = __webpack_require__(2);

	util = __webpack_require__(1);

	config = __webpack_require__(3)();

	exports = module.exports = Stapes.subclass({
	  constructor: function($el1, options) {
	    this.$el = $el1;
	    if (options == null) {
	      options = {};
	    }
	    this.options = $.extend({
	      viewClass: 'mcore-app-view',
	      routeChange: route.Route.changeByLocationHash
	    }, options);
	    this.router = new route.Route(this.options.routeChange);
	    this.curView = null;
	    this._onLoadViw = false;
	    this._middlewares = [];
	  },
	  route: function(path, viewName) {
	    var self;
	    self = this;
	    this.router.add(path, function() {
	      return self.runView(viewName, this, arguments);
	    });
	    return this;
	  },
	  use: function(middleware) {
	    this._middlewares.push(middleware);
	    return this;
	  },
	  _runView: function(done) {
	    if (done == null) {
	      done = function() {};
	    }
	    this.curView.instantiate.route = this.env.route;
	    this.curView.instantiate.context = this.env.context;
	    this.curView.instantiate.run.apply(this.curView.instantiate, this.env.args);
	    this.emit('runView', this.curView);
	    return done(this.curView.instantiate);
	  },
	  stack: function(ix, err, done) {
	    var middleware, next, nextIx;
	    if (ix == null) {
	      ix = 0;
	    }
	    if (err == null) {
	      err = null;
	    }
	    if (done == null) {
	      done = function() {};
	    }
	    if (ix === this._middlewares.length) {
	      return this._runView(done);
	    }
	    middleware = this._middlewares[ix];
	    nextIx = ix + 1;
	    next = (function(_this) {
	      return function(err) {
	        return _this.stack(nextIx, err, done);
	      };
	    })(this);
	    this.env.view = this.curView.instantiate;
	    return middleware.call(this.env, err, next);
	  },
	  runMiddlewares: function(done) {
	    if (done == null) {
	      done = function() {};
	    }
	    if (this._middlewares.length === 0) {
	      return this._runView(done);
	    }
	    return this.stack(0, null, done);
	  },
	  _initView: function(View, viewName) {
	    var $el;
	    $el = $("<div class='" + this.options.viewClass + "' />");
	    this.curView = {
	      name: viewName,
	      instantiate: new View($el, this)
	    };
	    return this.runMiddlewares((function(_this) {
	      return function() {
	        _this.curView.instantiate.$el.appendTo(_this.$el);
	        _this.curView.instantiate.afterRun();
	        return _this._onLoadViw = false;
	      };
	    })(this));
	  },
	  runView: function(viewName, route, args) {
	    var View;
	    if (this._onLoadViw) {
	      return;
	    }
	    View = false;
	    if (false === util.isString(viewName)) {
	      View = viewName;
	      viewName = View.viewName;
	    }
	    this.env = {
	      route: route,
	      context: route.context,
	      args: args,
	      viewName: viewName,
	      app: this
	    };
	    if (this.curView) {
	      if (this.curView.name === viewName) {
	        this.runMiddlewares((function(_this) {
	          return function() {
	            return _this.curView.instantiate.afterRun();
	          };
	        })(this));
	        return;
	      } else {
	        this.emit('destroyView', this.curView);
	        this.curView.instantiate.destroy();
	        this.curView = null;
	      }
	    }
	    this._onLoadViw = true;
	    if (View) {
	      return this._initView(View, viewName);
	    } else {
	      return config.AMDLoader([viewName], (function(_this) {
	        return function(View) {
	          return _this._initView(View, viewName);
	        };
	      })(this));
	    }
	  },
	  run: function() {
	    return this.router.run();
	  }
	});


/***/ }
/******/ ])
});
;