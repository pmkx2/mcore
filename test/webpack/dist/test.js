(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * 
	 * @date 2016-01-09 14:12:49
	 * @author vfasky <vfasky@gmail.com>
	 * @link http://vfasky.com
	 */
	'use strict';
	var Template;

	Template = __webpack_require__(1).Template;

	exports.test = function() {
	  var tpl;
	  tpl = new Template;
	  return tpl.render(__webpack_require__(15), {
	    id: 'test2',
	    list: [
	      {
	        name: 'ok1'
	      }, {
	        name: 'ok2'
	      }
	    ],
	    books: {
	      '1': {
	        id: 0,
	        name: 'book1'
	      },
	      '2': {
	        id: 1,
	        name: 'book2'
	      }
	    }
	  }, function() {
	    document.body.appendChild(tpl.refs);
	    return setInterval(function() {
	      tpl.set('time', (new Date()).getTime());
	      return tpl.scope.books.change = {
	        id: 'v',
	        name: new Date()
	      };
	    }, 1000);
	  });
	};


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * mcore simple MVVM
	 * @date 2016-01-07 21:46:45
	 * @author vfasky <vfasky@gmail.com>
	 * @link http://vfasky.com
	 */
	'use strict';
	module.exports = {
	  version: '2.0.0',
	  virtualDom: __webpack_require__(2),
	  EventEmitter: __webpack_require__(10),
	  Template: __webpack_require__(12)
	};


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * simple-virtual-dom
	 * @date 2016-01-07 21:50:58
	 */
	'use strict';
	var Element, diff, el, patch, ref, render;

	ref = __webpack_require__(3), el = ref.el, diff = ref.diff, patch = ref.patch;

	Element = el;

	render = el.prototype.render;

	Element.prototype.render = function() {
	  el = render.call(this);
	  console.log(el);
	  return el;
	};

	module.exports = {
	  el: Element,
	  diff: diff,
	  patch: patch
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	exports.el = __webpack_require__(4)
	exports.diff = __webpack_require__(6)
	exports.patch = __webpack_require__(7)


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5)

	/**
	 * Virtual-dom Element.
	 * @param {String} tagName
	 * @param {Object} props - Element's properties,
	 *                       - using object to store key-value pair
	 * @param {Array<Element|String>} - This element's children elements.
	 *                                - Can be Element instance or just a piece plain text.
	 */
	function Element (tagName, props, children) {
	  if (!(this instanceof Element)) {
	    return new Element(tagName, props, children)
	  }

	  if (_.isArray(props)) {
	    children = props
	    props = {}
	  }

	  this.tagName = tagName
	  this.props = props || {}
	  this.children = children || []
	  this.key = props
	    ? props.key
	    : void 666

	  var count = 0

	  _.each(this.children, function (child, i) {
	    if (child instanceof Element) {
	      count += child.count
	    } else {
	      children[i] = '' + child
	    }
	    count++
	  })

	  this.count = count
	}

	/**
	 * Render the hold element tree.
	 */
	Element.prototype.render = function () {
	  var el = document.createElement(this.tagName)
	  var props = this.props

	  for (var propName in props) {
	    var propValue = props[propName]
	    _.setAttr(el, propName, propValue)
	  }

	  var children = this.children || []

	  _.each(children, function (child) {
	    var childEl = (child instanceof Element)
	      ? child.render()
	      : document.createTextNode(child)
	    el.appendChild(childEl)
	  })

	  return el
	}

	module.exports = Element


/***/ },
/* 5 */
/***/ function(module, exports) {

	var _ = exports

	_.type = function (obj) {
	  return Object.prototype.toString.call(obj).replace(/\[object\s|\]/g, '')
	}

	_.isArray = function isArray (list) {
	  return _.type(list) === 'Array'
	}

	_.isString = function isString (list) {
	  return _.type(list) === 'String'
	}

	_.each = function each (array, fn) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    fn(array[i], i)
	  }
	}

	_.toArray = function toArray (listLike) {
	  if (!listLike) {
	    return []
	  }

	  var list = []

	  for (var i = 0, len = listLike.length; i < len; i++) {
	    list.push(listLike[i])
	  }

	  return list
	}

	_.setAttr = function setAttr (node, key, value) {
	  switch (key) {
	    case 'style':
	      node.style.cssText = value
	      break
	    case 'value':
	      var tagName = node.tagName || ''
	      tagName = tagName.toLowerCase()
	      if (
	        tagName === 'input' || tagName === 'textarea'
	      ) {
	        node.value = value
	      } else {
	        // if it is not a input or textarea, use `setAttribute` to set
	        node.setAttribute(key, value)
	      }
	      break
	    default:
	      node.setAttribute(key, value)
	      break
	  }
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5)
	var patch = __webpack_require__(7)
	var listDiff = __webpack_require__(8)

	function diff (oldTree, newTree) {
	  var index = 0
	  var patches = {}
	  dfsWalk(oldTree, newTree, index, patches)
	  return patches
	}

	function dfsWalk (oldNode, newNode, index, patches) {
	  var currentPatch = []

	  // node is removed
	  if (newNode === null) {
	    // will be removed when perform reordering, so has no needs to do anthings in here
	  // textNode content replacing
	  } else if (_.isString(oldNode) && _.isString(newNode)) {
	    if (newNode !== oldNode) {
	      currentPatch.push({ type: patch.TEXT, content: newNode })
	    }
	  // nodes are the same, diff its props and children
	  } else if (
	      oldNode.tagName === newNode.tagName &&
	      oldNode.key === newNode.key
	    ) {
	    // diff props
	    var propsPatches = diffProps(oldNode, newNode)
	    if (propsPatches) {
	      currentPatch.push({ type: patch.PROPS, props: propsPatches })
	    }
	    // diff children
	    diffChildren(oldNode.children, newNode.children, index, patches, currentPatch)
	  // nodes are not the same, replace the old node with new node
	  } else {
	    currentPatch.push({ type: patch.REPLACE, node: newNode })
	  }

	  if (currentPatch.length) {
	    patches[index] = currentPatch
	  }
	}

	function diffChildren (oldChildren, newChildren, index, patches, currentPatch) {
	  var diffs = listDiff(oldChildren, newChildren, 'key')
	  newChildren = diffs.children

	  if (diffs.moves.length) {
	    var reorderPatch = { type: patch.REORDER, moves: diffs.moves }
	    currentPatch.push(reorderPatch)
	  }

	  var leftNode = null
	  var currentNodeIndex = index
	  _.each(oldChildren, function (child, i) {
	    var newChild = newChildren[i]
	    currentNodeIndex = (leftNode && leftNode.count)
	      ? currentNodeIndex + leftNode.count + 1
	      : currentNodeIndex + 1
	    dfsWalk(child, newChild, currentNodeIndex, patches)
	    leftNode = child
	  })
	}

	function diffProps (oldNode, newNode) {
	  var count = 0
	  var oldProps = oldNode.props
	  var newProps = newNode.props

	  var key, value
	  var propsPatches = {}

	  // find out different properties
	  for (key in oldProps) {
	    value = oldProps[key]
	    if (newProps[key] !== value) {
	      count++
	      propsPatches[key] = newProps[key]
	    }
	  }

	  // find out new property
	  for (key in newProps) {
	    value = newProps[key]
	    if (!oldProps.hasOwnProperty(key)) {
	      count++
	      propsPatches[key] = newProps[key]
	    }
	  }

	  // if properties all are identical
	  if (count === 0) {
	    return null
	  }

	  return propsPatches
	}

	module.exports = diff


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5)

	var REPLACE = 0
	var REORDER = 1
	var PROPS = 2
	var TEXT = 3

	function patch (node, patches) {
	  var walker = {index: 0}
	  dfsWalk(node, walker, patches)
	}

	function dfsWalk (node, walker, patches) {
	  var currentPatches = patches[walker.index]

	  var len = node.childNodes
	    ? node.childNodes.length
	    : 0
	  for (var i = 0; i < len; i++) {
	    var child = node.childNodes[i]
	    walker.index++
	    dfsWalk(child, walker, patches)
	  }

	  if (currentPatches) {
	    applyPatches(node, currentPatches)
	  }
	}

	function applyPatches (node, currentPatches) {
	  _.each(currentPatches, function (currentPatch) {
	    switch (currentPatch.type) {
	      case REPLACE:
	        node.parentNode.replaceChild(currentPatch.node.render(), node)
	        break
	      case REORDER:
	        reorderChildren(node, currentPatch.moves)
	        break
	      case PROPS:
	        setProps(node, currentPatch.props)
	        break
	      case TEXT:
	        if (node.textContent) {
	          node.textContent = currentPatch.content
	        } else {
	          // fuck ie
	          node.nodeValue = currentPatch.content
	        }
	        break
	      default:
	        throw new Error('Unknown patch type ' + currentPatch.type)
	    }
	  })
	}

	function setProps (node, props) {
	  for (var key in props) {
	    if (props[key] === void 666) {
	      node.removeAttribute(key)
	    } else {
	      var value = props[key]
	      _.setAttr(node, key, value)
	    }
	  }
	}

	function reorderChildren (node, moves) {
	  var staticNodeList = _.toArray(node.childNodes)
	  var maps = {}

	  _.each(staticNodeList, function (node) {
	    if (node.nodeType === 1) {
	      var key = node.getAttribute('key')
	      if (key) {
	        maps[key] = node
	      }
	    }
	  })

	  _.each(moves, function (move) {
	    var index = move.index
	    if (move.type === 0) { // remove item
	      if (staticNodeList[index] === node.childNodes[index]) { // maybe have been removed for inserting
	        node.removeChild(node.childNodes[index])
	      }
	      staticNodeList.splice(index, 1)
	    } else if (move.type === 1) { // insert item
	      var insertNode = maps[move.item.key]
	        ? maps[move.item.key] // reuse old item
	        : (typeof move.item === 'object')
	            ? move.item.render()
	            : document.createTextNode(move.item)
	      staticNodeList.splice(index, 0, insertNode)
	      node.insertBefore(insertNode, node.childNodes[index] || null)
	    }
	  })
	}

	patch.REPLACE = REPLACE
	patch.REORDER = REORDER
	patch.PROPS = PROPS
	patch.TEXT = TEXT

	module.exports = patch


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(9).diff


/***/ },
/* 9 */
/***/ function(module, exports) {

	/**
	 * Diff two list in O(N).
	 * @param {Array} oldList - Original List
	 * @param {Array} newList - List After certain insertions, removes, or moves
	 * @return {Object} - {moves: <Array>}
	 *                  - moves is a list of actions that telling how to remove and insert
	 */
	function diff (oldList, newList, key) {
	  var oldMap = makeKeyIndexAndFree(oldList, key)
	  var newMap = makeKeyIndexAndFree(newList, key)

	  var newFree = newMap.free

	  var oldKeyIndex = oldMap.keyIndex
	  var newKeyIndex = newMap.keyIndex

	  var moves = []

	  // a simulate list to manipulate
	  var children = []
	  var i = 0
	  var item
	  var itemKey
	  var freeIndex = 0

	  // fist pass to check item in old list: if it's removed or not
	  while (i < oldList.length) {
	    item = oldList[i]
	    itemKey = getItemKey(item, key)
	    if (itemKey) {
	      if (!newKeyIndex.hasOwnProperty(itemKey)) {
	        children.push(null)
	      } else {
	        var newItemIndex = newKeyIndex[itemKey]
	        children.push(newList[newItemIndex])
	      }
	    } else {
	      var freeItem = newFree[freeIndex++]
	      children.push(freeItem || null)
	    }
	    i++
	  }

	  var simulateList = children.slice(0)

	  // remove items no longer exist
	  i = 0
	  while (i < simulateList.length) {
	    if (simulateList[i] === null) {
	      remove(i)
	      removeSimulate(i)
	    } else {
	      i++
	    }
	  }

	  // i is cursor pointing to a item in new list
	  // j is cursor pointing to a item in simulateList
	  var j = i = 0
	  while (i < newList.length) {
	    item = newList[i]
	    itemKey = getItemKey(item, key)

	    var simulateItem = simulateList[j]
	    var simulateItemKey = getItemKey(simulateItem, key)

	    if (simulateItem) {
	      if (itemKey === simulateItemKey) {
	        j++
	      } else {
	        // new item, just inesrt it
	        if (!oldKeyIndex.hasOwnProperty(itemKey)) {
	          insert(i, item)
	        } else {
	          // if remove current simulateItem make item in right place
	          // then just remove it
	          var nextItemKey = getItemKey(simulateList[j + 1], key)
	          if (nextItemKey === itemKey) {
	            remove(i)
	            removeSimulate(j)
	            j++ // after removing, current j is right, just jump to next one
	          } else {
	            // else insert item
	            insert(i, item)
	          }
	        }
	      }
	    } else {
	      insert(i, item)
	    }

	    i++
	  }

	  function remove (index) {
	    var move = {index: index, type: 0}
	    moves.push(move)
	  }

	  function insert (index, item) {
	    var move = {index: index, item: item, type: 1}
	    moves.push(move)
	  }

	  function removeSimulate (index) {
	    simulateList.splice(index, 1)
	  }

	  return {
	    moves: moves,
	    children: children
	  }
	}

	/**
	 * Convert list to key-item keyIndex object.
	 * @param {Array} list
	 * @param {String|Function} key
	 */
	function makeKeyIndexAndFree (list, key) {
	  var keyIndex = {}
	  var free = []
	  for (var i = 0, len = list.length; i < len; i++) {
	    var item = list[i]
	    var itemKey = getItemKey(item, key)
	    if (itemKey) {
	      keyIndex[itemKey] = i
	    } else {
	      free.push(item)
	    }
	  }
	  return {
	    keyIndex: keyIndex,
	    free: free
	  }
	}

	function getItemKey (item, key) {
	  if (!item || !key) return void 666
	  return typeof key === 'string'
	    ? item[key]
	    : key(item)
	}

	exports.makeKeyIndexAndFree = makeKeyIndexAndFree // exports for test
	exports.diff = diff


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * EventEmitter
	 * @date 2016-01-07 21:57:26
	 */
	'use strict';
	module.exports = __webpack_require__(11);


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//
	// We store our EE objects in a plain object whose properties are event names.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// `~` to make sure that the built-in object properties are not overridden or
	// used as an attack vector.
	// We also assume that `Object.create(null)` is available when the event name
	// is an ES6 Symbol.
	//
	var prefix = typeof Object.create !== 'function' ? '~' : false;

	/**
	 * Representation of a single EventEmitter function.
	 *
	 * @param {Function} fn Event handler to be called.
	 * @param {Mixed} context Context for function execution.
	 * @param {Boolean} once Only emit once
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() { /* Nothing to set */ }

	/**
	 * Holds the assigned EventEmitters by name.
	 *
	 * @type {Object}
	 * @private
	 */
	EventEmitter.prototype._events = undefined;

	/**
	 * Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @param {Boolean} exists We only need to know if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event
	    , available = this._events && this._events[evt];

	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];

	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }

	  return ee;
	};

	/**
	 * Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events || !this._events[evt]) return false;

	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;

	  if ('function' === typeof listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }

	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Functon} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this)
	    , evt = prefix ? prefix + event : event;

	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }

	  return this;
	};

	/**
	 * Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true)
	    , evt = prefix ? prefix + event : event;

	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }

	  return this;
	};

	/**
	 * Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events || !this._events[evt]) return this;

	  var listeners = this._events[evt]
	    , events = [];

	  if (fn) {
	    if (listeners.fn) {
	      if (
	           listeners.fn !== fn
	        || (once && !listeners.once)
	        || (context && listeners.context !== context)
	      ) {
	        events.push(listeners);
	      }
	    } else {
	      for (var i = 0, length = listeners.length; i < length; i++) {
	        if (
	             listeners[i].fn !== fn
	          || (once && !listeners[i].once)
	          || (context && listeners[i].context !== context)
	        ) {
	          events.push(listeners[i]);
	        }
	      }
	    }
	  }

	  //
	  // Reset the array, or remove it completely if we have no more listeners.
	  //
	  if (events.length) {
	    this._events[evt] = events.length === 1 ? events[0] : events;
	  } else {
	    delete this._events[evt];
	  }

	  return this;
	};

	/**
	 * Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  if (!this._events) return this;

	  if (event) delete this._events[prefix ? prefix + event : event];
	  else this._events = prefix ? {} : Object.create(null);

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * 基于 virtual dom 的模板引擎
	 * @date 2016-01-09 16:39:56
	 * @author vfasky <vfasky@gmail.com>
	 * @link http://vfasky.com
	 */
	'use strict';
	var EventEmitter, Template, clone, diff, nextTick, patch, ref, ref1, util,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  slice = [].slice;

	EventEmitter = __webpack_require__(10);

	util = __webpack_require__(13);

	ref = __webpack_require__(13), clone = ref.clone, nextTick = ref.nextTick;

	ref1 = __webpack_require__(2), diff = ref1.diff, patch = ref1.patch;

	Template = (function(superClass) {
	  extend(Template, superClass);

	  function Template() {
	    this._status = 0;
	    this._queueId = null;
	    this.refs = null;
	    this.virtualDomDefine = null;
	    this.virtualDom = null;
	    this.scope = {};
	    this.init();
	  }

	  Template.prototype.watchScope = function() {
	    if (this.__initWatch) {
	      return;
	    }
	    return this.__initWatch = true;
	  };

	  Template.prototype.set = function() {
	    var args, doneOrAsync, key, val;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    doneOrAsync = null;
	    if (args.length > 1) {
	      key = args[0];
	      val = args[1];
	      this.scope[key] = val;
	      if (args.length === 3) {
	        doneOrAsync = args[2];
	      }
	    } else {
	      return;
	    }
	    if (this._status === 0) {
	      return;
	    }
	    this.emit('changeScope', this.scope, key, val);
	    return this.renderQueue(doneOrAsync);
	  };

	  Template.prototype.get = function(key, defaultVal) {
	    if (defaultVal == null) {
	      defaultVal = null;
	    }
	    if (this.scope.hasOwnProperty(key)) {
	      return this.scope[key];
	    }
	    return defaultVal;
	  };

	  Template.prototype.destroy = function() {
	    if (this.__initWatch) {
	      Object.unobserve(this.scope);
	    }
	    if (this.refs && this.refs.parentNode && this.refs.parentNode.removeChild) {
	      return this.refs.parentNode.removeChild(this.refs);
	    }
	  };

	  Template.prototype.init = function() {};

	  Template.prototype._render = function(done) {
	    var patches, scope, virtualDom;
	    scope = util.extend(true, this.scope);
	    virtualDom = this.virtualDomDefine(scope);
	    if (this.virtualDom === null) {
	      this.virtualDom = virtualDom;
	      this.refs = this.virtualDom.render();
	    } else {
	      patches = diff(this.virtualDom, virtualDom);
	      this.virtualDom = virtualDom;
	      console.log(patches);
	      patch(this.refs, patches);
	    }
	    this._status = 2;
	    this.emit('rendered');
	    if (util.isFunction(done)) {
	      return done();
	    }
	  };

	  Template.prototype.renderQueue = function(doneOrAsync) {
	    nextTick.clear(this._queueId);
	    if (true === doneOrAsync) {
	      return this._render();
	    } else {
	      this._status = 1;
	      return this._queueId = nextTick((function(_this) {
	        return function() {
	          return _this._render(doneOrAsync);
	        };
	      })(this));
	    }
	  };

	  Template.prototype.render = function(virtualDomDefine, scope, doneOrAsync) {
	    var ix, scopeKeys, scopeLen;
	    this.virtualDomDefine = virtualDomDefine;
	    if (scope == null) {
	      scope = {};
	    }
	    if (doneOrAsync == null) {
	      doneOrAsync = function() {};
	    }
	    this._status = 1;
	    this.emit('beforeRender');
	    scopeKeys = Object.keys(scope);
	    scopeLen = scopeKeys.length;
	    if (scopeLen === 0) {
	      this.renderQueue(doneOrAsync);
	    } else {
	      ix = scopeLen - 1;
	      scopeKeys.forEach((function(_this) {
	        return function(v, k) {
	          return _this.set(v, scope[v], k === ix && doneOrAsync || null);
	        };
	      })(this));
	    }
	    this.watchScope();
	    return this;
	  };

	  return Template;

	})(EventEmitter);

	Template.formatters = __webpack_require__(14);

	Template.components = {};

	Template.binders = {};

	module.exports = Template;


/***/ },
/* 13 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * 
	 * @date 2016-01-11 20:41:14
	 * @author vfasky <vfasky@gmail.com>
	 * @link http://vfasky.com
	 */
	'use strict';
	var _isNumberReg;

	_isNumberReg = /^-{0,1}\d*\.{0,1}\d+$/;

	exports.isNumber = function(x) {
	  return _isNumberReg.test(x);
	};

	exports.isArray = function(x) {
	  if (Array.isArray) {
	    return Array.isArray(x);
	  }
	  return Object.prototype.toString.call(x) === '[object Array]';
	};

	exports.isObject = function(x) {
	  return Object.prototype.toString.call(x) === '[object Object]';
	};

	exports.isString = function(x) {
	  return Object.prototype.toString.call(x) === '[object String]';
	};

	exports.isFunction = function(x) {
	  return Object.prototype.toString.call(x) === '[object Function]';
	};

	exports.isPlainObject = function(x) {
	  var hasIsPropertyOfMethod, hasOwnConstructor, key, lastKey;
	  if (!x || Object.prototype.toString.call(x) !== '[object Object]' || x.nodeType || x.setInterval) {
	    return false;
	  }
	  hasOwnConstructor = Object.hasOwnProperty.call(x, 'constructor');
	  hasIsPropertyOfMethod = Object.hasOwnProperty.call(x.constructor.prototype, 'isPrototypeOf');
	  if (x.constructor && !hasOwnConstructor && !hasIsPropertyOfMethod) {
	    return false;
	  }
	  for (key in x) {
	    lastKey = key;
	  }
	  return typeof lastKey === 'undefined' || Object.hasOwnProperty.call(x, lastKey);
	};

	exports.extend = function() {
	  var clone, copy, deep, i, j, length, name, options, ref, ref1, src, start, target;
	  target = arguments[0] || {};
	  length = arguments.length;
	  deep = false;
	  start = 1;
	  if (typeof target === 'boolean') {
	    deep = target;
	    target = arguments[1] || {};
	    start = 2;
	  }
	  if (typeof target !== 'object' && typeof target !== 'function') {
	    target = {};
	  }
	  for (i = j = ref = start, ref1 = length; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
	    if ((options = arguments[i]) !== null) {
	      for (name in options) {
	        src = target[name];
	        copy = options[name];
	        if (target === copy) {
	          continue;
	        }
	        if (deep && copy && (exports.isPlainObject(copy) || exports.isArray(copy))) {
	          clone = {};
	          if (src && (exports.isPlainObject(src) || exports.isArray(src))) {
	            clone = exports.isArray(copy) && [] || {};
	          }
	          target[name] = exports.extend(deep, clone, copy);
	        } else if (typeof copy !== 'undefined') {
	          target[name] = copy;
	        }
	      }
	    }
	  }
	  return target;
	};

	(function() {
	  if (window.requestAnimationFrame) {
	    exports.nextTick = function(fun) {
	      return window.requestAnimationFrame(function() {
	        return fun();
	      });
	    };
	    return exports.nextTick.clear = function(id) {
	      if (id) {
	        return window.cancelAnimationFrame(id);
	      }
	    };
	  } else {
	    exports.nextTick = function(fun) {
	      return setTimeout(fun, 0);
	    };
	    return exports.nextTick.clear = function(id) {
	      if (id) {
	        return clearTimeout(id);
	      }
	    };
	  }
	})();


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0

	/**
	 * 过滤函数
	 * @date 2016-01-13 18:07:10
	 * @author vfasky <vfasky@gmail.com>
	 * @link http://vfasky.com
	 */
	'use strict';
	var Template, util;

	Template = __webpack_require__(12);

	util = __webpack_require__(13);

	exports['toNumber'] = function(x) {
	  if (false === util.isNumber(x)) {
	    return 0;
	  }
	  return Number(x);
	};

	exports['toFixed'] = function(x, len) {
	  if (len == null) {
	    len = 1;
	  }
	  return Number(x).toFixed(len);
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	var mcore = __webpack_require__(1);
	var el = mcore.virtualDom.el;
	var formatters = mcore.Template.formatters;
	 
	module.exports = function(scope){
	    var children_0 = [];
	    
	    (function(scope, tree){ // startTree 0

	        var children_0 = [], attr = {};


	        (function(scope, tree){ // startTree 1

	            var children_1 = [], attr = {};

	            var __mc__rp__key_0;
	            __mc__rp__key_0 = scope.time; 

	            tree.push( "" + __mc__rp__key_0 + "" );
	        })(scope, children_0); // endTree 1

	        tree.push( el('h2', attr, children_0) );
	        var children_2 = [], attr = {};
	        attr['data-id'] = scope.id; 


	        (function(scope, tree){ // startTree 3

	            var children_3 = [], attr = {};


	            (function(scope, tree){ // startTree 4

	                // for v, k in scope.list
	                var __mc__arr = scope.list || [];
	                for(var k=0, len=__mc__arr.length; k < len; k++){
	                    var v = __mc__arr[k];
	                    
	                    // if scope.time
	                    if( scope.time ){
	                       
	                        var children_6 = [], attr = {};


	                        (function(scope, tree){ // startTree 7

	                            var children_7 = [], attr = {};

	                            var __mc__rp__key_0;
	                            __mc__rp__key_0 = v.name; 

	                            tree.push( "             " + __mc__rp__key_0 + "              " );
	                            var children_8 = [], attr = {};


	                            (function(scope, tree){ // startTree 9

	                                var children_9 = [], attr = {};

	                                var __mc__rp__key_0;
	                                var __mc__rp__key_1;
	                                __mc__rp__key_0 = scope.time; 

	                                __mc__rp__key_1 = (k + 2) / 6; 

	                                tree.push( "" + __mc__rp__key_0 + "  " + __mc__rp__key_1 + "" );
	                            })(scope, children_8); // endTree 9

	                            tree.push( el('span', attr, children_8) );
	                            var children_10 = [], attr = {};
	                            attr['href'] = '#';

	                            (function(scope, tree){ // startTree 11

	                                var children_11 = [], attr = {};

	                                var __mc__rp__key_0;
	                                __mc__rp__key_0 = (new Date()).toString(); 

	                                tree.push( "t1 " + __mc__rp__key_0 + "" );
	                            })(scope, children_10); // endTree 11

	                            tree.push( el('a', attr, children_10) );
	                        })(scope, children_6); // endTree 7

	                        tree.push( el('li', attr, children_6) );
	                    }// endif 

	                } // endFor 

	            })(scope, children_3); // endTree 4

	            tree.push( el('ul', attr, children_3) );
	            var children_12 = [], attr = {};


	            (function(scope, tree){ // startTree 13

	                // for v, k in scope.list
	                var __mc__arr = scope.list || [];
	                for(var k=0, len=__mc__arr.length; k < len; k++){
	                    var v = __mc__arr[k];
	                    
	                    // if scope.time
	                    if( !(scope.time) ){
	                       
	                        var children_15 = [], attr = {};


	                        (function(scope, tree){ // startTree 16

	                            var children_16 = [], attr = {};

	                            var __mc__rp__key_0;
	                            var __mc__rp__key_1;
	                            __mc__rp__key_0 = v.name; 

	    
	                            __mc__rp__key_1 = (function(x){
	                                    // toNumber
	                                if( formatters.hasOwnProperty('toNumber') ) {
	                                    x = formatters['toNumber'](x);
	                                } // end toNumber 
	                                // toFixed
	                                if( formatters.hasOwnProperty('toFixed') ) {
	                                    x = formatters['toFixed'](x,2);
	                                } // end toFixed 
	                                return x;
	                            })(k);

	                            tree.push( "             " + __mc__rp__key_0 + " " + __mc__rp__key_1 + "         " );
	                        })(scope, children_15); // endTree 16

	                        tree.push( el('li', attr, children_15) );
	                    }// endif 

	                } // endFor 

	            })(scope, children_12); // endTree 13

	            tree.push( el('ul', attr, children_12) );
	            // each mc-each-v = scope.list
	            var __mc__arr = scope.list || [];
	            for(var __mc__$ix_=0, len=__mc__arr.length; __mc__$ix_ < len; __mc__$ix_++){
	                var v = __mc__arr[__mc__$ix_];
	                
	                var children_18 = [], attr = {};


	                (function(scope, tree){ // startTree 19

	                    var children_19 = [], attr = {};

	                    var __mc__rp__key_0;
	                    __mc__rp__key_0 = v.name; 

	                    tree.push( " " + __mc__rp__key_0 + " " );
	                })(scope, children_18); // endTree 19

	                tree.push( el('h5', attr, children_18) );
	            }// endEach

	            var children_20 = [], attr = {};


	            tree.push( el('br', attr, children_20) );
	            var children_21 = [], attr = {};
	            attr['type'] = 'button';    
	            attr['value'] = (function(x){
	                    // toNumber
	                if( formatters.hasOwnProperty('toNumber') ) {
	                    x = formatters['toNumber'](x);
	                } // end toNumber 
	                // toFixed
	                if( formatters.hasOwnProperty('toFixed') ) {
	                    x = formatters['toFixed'](x,2);
	                } // end toFixed 
	                return x;
	            })(v.name);


	            tree.push( el('input', attr, children_21) );
	            // for k, v of scope.books
	            var __mc__obj = scope.books || {};
	            for(var k in __mc__obj){
	                var  v = __mc__obj[k] || {};
	                
	                var children_23 = [], attr = {};
	                attr['href'] = v.id; 


	                (function(scope, tree){ // startTree 24

	                    var children_24 = [], attr = {};

	                    var __mc__rp__key_0;
	                    var __mc__rp__key_1;
	                    __mc__rp__key_0 = v.name; 

	                    __mc__rp__key_1 = k; 

	                    tree.push( "" + __mc__rp__key_0 + " - " + __mc__rp__key_1 + " " );
	                    var children_25 = [], attr = {};


	                    tree.push( el('br', attr, children_25) );
	                })(scope, children_23); // endTree 24

	                tree.push( el('a', attr, children_23) );
	            } // endFor 

	        })(scope, children_2); // endTree 3

	        tree.push( el('div', attr, children_2) );
	    })(scope, children_0); // endTree 0

	    return el('div', {'class': 'mc-vd'}, children_0);
	};

/***/ }
/******/ ])
});
;